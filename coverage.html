
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/illumio/cloud-operator/api/illumio/cloud/k8sclustersync/v1/k8s_info.pb.go (4.1%)</option>
				
				<option value="file1">github.com/illumio/cloud-operator/api/illumio/cloud/k8sclustersync/v1/k8s_info_grpc.pb.go (0.0%)</option>
				
				<option value="file2">github.com/illumio/cloud-operator/cmd/main.go (0.0%)</option>
				
				<option value="file3">github.com/illumio/cloud-operator/internal/controller/authenticator.go (1.3%)</option>
				
				<option value="file4">github.com/illumio/cloud-operator/internal/controller/authenticator_onboarding_credentials.go (0.0%)</option>
				
				<option value="file5">github.com/illumio/cloud-operator/internal/controller/flow_cilium.go (0.0%)</option>
				
				<option value="file6">github.com/illumio/cloud-operator/internal/controller/flow_falco.go (0.0%)</option>
				
				<option value="file7">github.com/illumio/cloud-operator/internal/controller/grpc_logger.go (38.7%)</option>
				
				<option value="file8">github.com/illumio/cloud-operator/internal/controller/k8s_resources.go (14.6%)</option>
				
				<option value="file9">github.com/illumio/cloud-operator/internal/controller/onboarding.go (0.0%)</option>
				
				<option value="file10">github.com/illumio/cloud-operator/internal/controller/resource_manager.go (3.2%)</option>
				
				<option value="file11">github.com/illumio/cloud-operator/internal/controller/streams.go (0.7%)</option>
				
				<option value="file12">github.com/illumio/cloud-operator/internal/controller/streams_helper.go (0.0%)</option>
				
				<option value="file13">github.com/illumio/cloud-operator/internal/controller/streams_retry.go (0.0%)</option>
				
				<option value="file14">github.com/illumio/cloud-operator/internal/controller/testhelper/set_up_test_cluster.go (50.0%)</option>
				
				<option value="file15">github.com/illumio/cloud-operator/internal/version/version.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2024 Illumio, Inc. All Rights Reserved.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        (unknown)
// source: illumio/cloud/k8sclustersync/v1/k8s_info.proto

package k8sclustersyncv1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Enum for CniPluginStatus that defines possible states of the CNI plugin.
type FlowCollector int32

const (
        // Default value. This value is unused and should not be set.
        FlowCollector_FLOW_COLLECTOR_UNSPECIFIED FlowCollector = 0
        // Indicates that no suitable network flow collection mechanism is available in the k8s cluster.
        FlowCollector_FLOW_COLLECTOR_DISABLED FlowCollector = 1
        // Indicates that the Cilium CNI plugin is deployed with Hubble Relay and is used for collecting network flows.
        FlowCollector_FLOW_COLLECTOR_CILIUM FlowCollector = 2
        // Indicates that Falco is deployed and configured for collecting network flows.
        FlowCollector_FLOW_COLLECTOR_FALCO FlowCollector = 3
)

// Enum value maps for FlowCollector.
var (
        FlowCollector_name = map[int32]string{
                0: "FLOW_COLLECTOR_UNSPECIFIED",
                1: "FLOW_COLLECTOR_DISABLED",
                2: "FLOW_COLLECTOR_CILIUM",
                3: "FLOW_COLLECTOR_FALCO",
        }
        FlowCollector_value = map[string]int32{
                "FLOW_COLLECTOR_UNSPECIFIED": 0,
                "FLOW_COLLECTOR_DISABLED":    1,
                "FLOW_COLLECTOR_CILIUM":      2,
                "FLOW_COLLECTOR_FALCO":       3,
        }
)

func (x FlowCollector) Enum() *FlowCollector <span class="cov0" title="0">{
        p := new(FlowCollector)
        *p = x
        return p
}</span>

func (x FlowCollector) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (FlowCollector) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_enumTypes[0].Descriptor()
}</span>

func (FlowCollector) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_enumTypes[0]
}</span>

func (x FlowCollector) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use FlowCollector.Descriptor instead.
func (FlowCollector) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{0}
}</span>

// TrafficDirection contains TrafficDirectopm header flags of a flow.
// https://pkg.go.dev/github.com/cilium/cilium/api/v1/flow#readme-trafficdirection
type TrafficDirection int32

const (
        TrafficDirection_TRAFFIC_DIRECTION_TRAFFIC_DIRECTION_UNKNOWN_UNSPECIFIED TrafficDirection = 0
        TrafficDirection_TRAFFIC_DIRECTION_INGRESS                               TrafficDirection = 1
        TrafficDirection_TRAFFIC_DIRECTION_EGRESS                                TrafficDirection = 2
)

// Enum value maps for TrafficDirection.
var (
        TrafficDirection_name = map[int32]string{
                0: "TRAFFIC_DIRECTION_TRAFFIC_DIRECTION_UNKNOWN_UNSPECIFIED",
                1: "TRAFFIC_DIRECTION_INGRESS",
                2: "TRAFFIC_DIRECTION_EGRESS",
        }
        TrafficDirection_value = map[string]int32{
                "TRAFFIC_DIRECTION_TRAFFIC_DIRECTION_UNKNOWN_UNSPECIFIED": 0,
                "TRAFFIC_DIRECTION_INGRESS":                               1,
                "TRAFFIC_DIRECTION_EGRESS":                                2,
        }
)

func (x TrafficDirection) Enum() *TrafficDirection <span class="cov0" title="0">{
        p := new(TrafficDirection)
        *p = x
        return p
}</span>

func (x TrafficDirection) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (TrafficDirection) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_enumTypes[1].Descriptor()
}</span>

func (TrafficDirection) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_enumTypes[1]
}</span>

func (x TrafficDirection) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use TrafficDirection.Descriptor instead.
func (TrafficDirection) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{1}
}</span>

// Verdict contains Verdict header flags of a flow.
// https://pkg.go.dev/github.com/cilium/cilium/api/v1/flow#readme-verdict
type Verdict int32

const (
        Verdict_VERDICT_UNKNOWN_UNSPECIFIED Verdict = 0
        Verdict_VERDICT_FORWARDED           Verdict = 1
        Verdict_VERDICT_DROPPED             Verdict = 2
        Verdict_VERDICT_ERROR               Verdict = 3
        Verdict_VERDICT_AUDIT               Verdict = 4
        Verdict_VERDICT_REDIRECTED          Verdict = 5
        Verdict_VERDICT_TRACED              Verdict = 6
        Verdict_VERDICT_TRANSLATED          Verdict = 7
)

// Enum value maps for Verdict.
var (
        Verdict_name = map[int32]string{
                0: "VERDICT_UNKNOWN_UNSPECIFIED",
                1: "VERDICT_FORWARDED",
                2: "VERDICT_DROPPED",
                3: "VERDICT_ERROR",
                4: "VERDICT_AUDIT",
                5: "VERDICT_REDIRECTED",
                6: "VERDICT_TRACED",
                7: "VERDICT_TRANSLATED",
        }
        Verdict_value = map[string]int32{
                "VERDICT_UNKNOWN_UNSPECIFIED": 0,
                "VERDICT_FORWARDED":           1,
                "VERDICT_DROPPED":             2,
                "VERDICT_ERROR":               3,
                "VERDICT_AUDIT":               4,
                "VERDICT_REDIRECTED":          5,
                "VERDICT_TRACED":              6,
                "VERDICT_TRANSLATED":          7,
        }
)

func (x Verdict) Enum() *Verdict <span class="cov0" title="0">{
        p := new(Verdict)
        *p = x
        return p
}</span>

func (x Verdict) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (Verdict) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_enumTypes[2].Descriptor()
}</span>

func (Verdict) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_enumTypes[2]
}</span>

func (x Verdict) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use Verdict.Descriptor instead.
func (Verdict) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{2}
}</span>

// IPVersion contains the IPVersion header flags of a flow.
// https://pkg.go.dev/github.com/cilium/cilium/api/v1/flow#readme-ipversion
type IPVersion int32

const (
        IPVersion_IP_VERSION_IP_NOT_USED_UNSPECIFIED IPVersion = 0
        IPVersion_IP_VERSION_IPV4                    IPVersion = 1
        IPVersion_IP_VERSION_IPV6                    IPVersion = 2
)

// Enum value maps for IPVersion.
var (
        IPVersion_name = map[int32]string{
                0: "IP_VERSION_IP_NOT_USED_UNSPECIFIED",
                1: "IP_VERSION_IPV4",
                2: "IP_VERSION_IPV6",
        }
        IPVersion_value = map[string]int32{
                "IP_VERSION_IP_NOT_USED_UNSPECIFIED": 0,
                "IP_VERSION_IPV4":                    1,
                "IP_VERSION_IPV6":                    2,
        }
)

func (x IPVersion) Enum() *IPVersion <span class="cov0" title="0">{
        p := new(IPVersion)
        *p = x
        return p
}</span>

func (x IPVersion) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (IPVersion) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_enumTypes[3].Descriptor()
}</span>

func (IPVersion) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_enumTypes[3]
}</span>

func (x IPVersion) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use IPVersion.Descriptor instead.
func (IPVersion) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{3}
}</span>

// Enumeration to define the different levels of logging.
type LogLevel int32

const (
        // Default unspecified log level.
        LogLevel_LOG_LEVEL_UNSPECIFIED LogLevel = 0
        // Debug log level, useful for development and troubleshooting.
        LogLevel_LOG_LEVEL_DEBUG LogLevel = 1
        // Informational log level for general application information.
        LogLevel_LOG_LEVEL_INFO LogLevel = 2
        // Warning log level for potentially problematic situations.
        LogLevel_LOG_LEVEL_WARN LogLevel = 3
        // Error log level indicating something went wrong.
        LogLevel_LOG_LEVEL_ERROR LogLevel = 4
)

// Enum value maps for LogLevel.
var (
        LogLevel_name = map[int32]string{
                0: "LOG_LEVEL_UNSPECIFIED",
                1: "LOG_LEVEL_DEBUG",
                2: "LOG_LEVEL_INFO",
                3: "LOG_LEVEL_WARN",
                4: "LOG_LEVEL_ERROR",
        }
        LogLevel_value = map[string]int32{
                "LOG_LEVEL_UNSPECIFIED": 0,
                "LOG_LEVEL_DEBUG":       1,
                "LOG_LEVEL_INFO":        2,
                "LOG_LEVEL_WARN":        3,
                "LOG_LEVEL_ERROR":       4,
        }
)

func (x LogLevel) Enum() *LogLevel <span class="cov0" title="0">{
        p := new(LogLevel)
        *p = x
        return p
}</span>

func (x LogLevel) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (LogLevel) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_enumTypes[4].Descriptor()
}</span>

func (LogLevel) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_enumTypes[4]
}</span>

func (x LogLevel) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use LogLevel.Descriptor instead.
func (LogLevel) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{4}
}</span>

// Application-level keepalives. While gRPC already has an HTTP-level keepalive
// mechanism, we have seen deployments where the server lives behind an ingress.
// The gRPC system-level keepalive (represented by the `-`s in the diagram)
// terminates at the ingress, and thus doesn't work end-to-end. This is solved
// with an application level keepalive (represented by the `=`s in the diagram)
//
// +----------------+       +---------+          +--------+
// |                +------&gt;+         +          +        |
// | cloud-operator +       + ingress +          + server |
// |                +======&gt;+         +=========&gt;+        |
// +----------------+       +---------+          +--------+
//
// Keepalives are important to us, because when the server restarts, the
// connection may be closed between the Ingress and the server - but not between
// the cloud-operator and the Ingress. Application-level keepalives will
// re-establish connections to the server faster than if we wait for reasons to
// send data over the channel
type Keepalive struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Keepalive) Reset() <span class="cov0" title="0">{
        *x = Keepalive{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Keepalive) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Keepalive) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Keepalive) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use Keepalive.ProtoReflect.Descriptor instead.
func (*Keepalive) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{0}
}</span>

// Metadata associated with a Kubernetes resource.
// https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.29/#objectmeta-v1-meta
type KubernetesObjectData struct {
        state             protoimpl.MessageState      `protogen:"open.v1"`
        Annotations       map[string]string           `protobuf:"bytes,1,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        CreationTimestamp *timestamppb.Timestamp      `protobuf:"bytes,2,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"`
        Kind              string                      `protobuf:"bytes,3,opt,name=kind,proto3" json:"kind,omitempty"`
        Labels            map[string]string           `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        Name              string                      `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
        Namespace         string                      `protobuf:"bytes,6,opt,name=namespace,proto3" json:"namespace,omitempty"`
        OwnerReferences   []*KubernetesOwnerReference `protobuf:"bytes,7,rep,name=owner_references,json=ownerReferences,proto3" json:"owner_references,omitempty"`
        ResourceVersion   string                      `protobuf:"bytes,8,opt,name=resource_version,json=resourceVersion,proto3" json:"resource_version,omitempty"`
        Uid               string                      `protobuf:"bytes,9,opt,name=uid,proto3" json:"uid,omitempty"`
        // Types that are valid to be assigned to KindSpecific:
        //
        //        *KubernetesObjectData_Pod
        //        *KubernetesObjectData_Node
        //        *KubernetesObjectData_Service
        KindSpecific  isKubernetesObjectData_KindSpecific `protobuf_oneof:"kind_specific"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *KubernetesObjectData) Reset() <span class="cov0" title="0">{
        *x = KubernetesObjectData{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *KubernetesObjectData) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*KubernetesObjectData) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *KubernetesObjectData) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use KubernetesObjectData.ProtoReflect.Descriptor instead.
func (*KubernetesObjectData) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{1}
}</span>

func (x *KubernetesObjectData) GetAnnotations() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Annotations
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *KubernetesObjectData) GetCreationTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreationTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *KubernetesObjectData) GetKind() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Kind
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *KubernetesObjectData) GetLabels() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Labels
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *KubernetesObjectData) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *KubernetesObjectData) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *KubernetesObjectData) GetOwnerReferences() []*KubernetesOwnerReference <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OwnerReferences
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *KubernetesObjectData) GetResourceVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ResourceVersion
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *KubernetesObjectData) GetUid() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Uid
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *KubernetesObjectData) GetKindSpecific() isKubernetesObjectData_KindSpecific <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.KindSpecific
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *KubernetesObjectData) GetPod() *KubernetesPodData <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.KindSpecific.(*KubernetesObjectData_Pod); ok </span><span class="cov0" title="0">{
                        return x.Pod
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (x *KubernetesObjectData) GetNode() *KubernetesNodeData <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.KindSpecific.(*KubernetesObjectData_Node); ok </span><span class="cov0" title="0">{
                        return x.Node
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (x *KubernetesObjectData) GetService() *KubernetesServiceData <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.KindSpecific.(*KubernetesObjectData_Service); ok </span><span class="cov0" title="0">{
                        return x.Service
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type isKubernetesObjectData_KindSpecific interface {
        isKubernetesObjectData_KindSpecific()
}

type KubernetesObjectData_Pod struct {
        Pod *KubernetesPodData `protobuf:"bytes,100,opt,name=pod,proto3,oneof"`
}

type KubernetesObjectData_Node struct {
        Node *KubernetesNodeData `protobuf:"bytes,101,opt,name=node,proto3,oneof"`
}

type KubernetesObjectData_Service struct {
        Service *KubernetesServiceData `protobuf:"bytes,102,opt,name=service,proto3,oneof"`
}

func (*KubernetesObjectData_Pod) isKubernetesObjectData_KindSpecific() {<span class="cov0" title="0">}</span>

func (*KubernetesObjectData_Node) isKubernetesObjectData_KindSpecific() {<span class="cov0" title="0">}</span>

func (*KubernetesObjectData_Service) isKubernetesObjectData_KindSpecific() {<span class="cov0" title="0">}</span>

type KubernetesServiceData struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // List of IP addresses associated with the Kubernetes service
        IpAddresses []string `protobuf:"bytes,1,rep,name=ip_addresses,json=ipAddresses,proto3" json:"ip_addresses,omitempty"`
        // List of service ports details
        Ports []*KubernetesServiceData_ServicePort `protobuf:"bytes,2,rep,name=ports,proto3" json:"ports,omitempty"`
        // Type of Kubernetes service (e.g., ClusterIP, NodePort, LoadBalancer, etc.)
        Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
        // The external reference that discovery mechanisms will
        // return as an alias for this service
        ExternalName *string `protobuf:"bytes,4,opt,name=external_name,json=externalName,proto3,oneof" json:"external_name,omitempty"`
        // The class of the load balancer implementation this Service belongs to
        LoadBalancerClass *string `protobuf:"bytes,5,opt,name=load_balancer_class,json=loadBalancerClass,proto3,oneof" json:"load_balancer_class,omitempty"`
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *KubernetesServiceData) Reset() <span class="cov0" title="0">{
        *x = KubernetesServiceData{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *KubernetesServiceData) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*KubernetesServiceData) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *KubernetesServiceData) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use KubernetesServiceData.ProtoReflect.Descriptor instead.
func (*KubernetesServiceData) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{2}
}</span>

func (x *KubernetesServiceData) GetIpAddresses() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IpAddresses
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *KubernetesServiceData) GetPorts() []*KubernetesServiceData_ServicePort <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ports
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *KubernetesServiceData) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *KubernetesServiceData) GetExternalName() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.ExternalName != nil </span><span class="cov0" title="0">{
                return *x.ExternalName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *KubernetesServiceData) GetLoadBalancerClass() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.LoadBalancerClass != nil </span><span class="cov0" title="0">{
                return *x.LoadBalancerClass
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// KubernetesNodeData contains information specific to a Node Object.
type KubernetesNodeData struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Node.spec.providerID
        ProviderId string `protobuf:"bytes,1,opt,name=provider_id,json=providerId,proto3" json:"provider_id,omitempty"`
        // List of ip addresses that are tied to Node so we can resolve them as workloads
        IpAddresses   []string `protobuf:"bytes,2,rep,name=ip_addresses,json=ipAddresses,proto3" json:"ip_addresses,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *KubernetesNodeData) Reset() <span class="cov0" title="0">{
        *x = KubernetesNodeData{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *KubernetesNodeData) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*KubernetesNodeData) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *KubernetesNodeData) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use KubernetesNodeData.ProtoReflect.Descriptor instead.
func (*KubernetesNodeData) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{3}
}</span>

func (x *KubernetesNodeData) GetProviderId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ProviderId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *KubernetesNodeData) GetIpAddresses() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IpAddresses
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// KubernetesPodData contains information specific to a Pod object.
// It currently holds the IP addresses allocated to a pod. If this field is specified, the 0th entry must match the podIP field.
// A Pod may be allocated at most 1 value for each of IPv4 and IPv6. This list is empty if no IPs have been allocated yet.
type KubernetesPodData struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        IpAddresses   []string               `protobuf:"bytes,1,rep,name=ip_addresses,json=ipAddresses,proto3" json:"ip_addresses,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *KubernetesPodData) Reset() <span class="cov0" title="0">{
        *x = KubernetesPodData{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *KubernetesPodData) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*KubernetesPodData) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *KubernetesPodData) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use KubernetesPodData.ProtoReflect.Descriptor instead.
func (*KubernetesPodData) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{4}
}</span>

func (x *KubernetesPodData) GetIpAddresses() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IpAddresses
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Information identifying an object owning a Kubernetes resource.
// https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.29/#ownerreference-v1-meta
type KubernetesOwnerReference struct {
        state              protoimpl.MessageState `protogen:"open.v1"`
        ApiVersion         string                 `protobuf:"bytes,1,opt,name=api_version,json=apiVersion,proto3" json:"api_version,omitempty"`
        BlockOwnerDeletion bool                   `protobuf:"varint,2,opt,name=block_owner_deletion,json=blockOwnerDeletion,proto3" json:"block_owner_deletion,omitempty"`
        Controller         bool                   `protobuf:"varint,3,opt,name=controller,proto3" json:"controller,omitempty"`
        Kind               string                 `protobuf:"bytes,4,opt,name=kind,proto3" json:"kind,omitempty"`
        Name               string                 `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
        Uid                string                 `protobuf:"bytes,6,opt,name=uid,proto3" json:"uid,omitempty"`
        unknownFields      protoimpl.UnknownFields
        sizeCache          protoimpl.SizeCache
}

func (x *KubernetesOwnerReference) Reset() <span class="cov0" title="0">{
        *x = KubernetesOwnerReference{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *KubernetesOwnerReference) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*KubernetesOwnerReference) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *KubernetesOwnerReference) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use KubernetesOwnerReference.ProtoReflect.Descriptor instead.
func (*KubernetesOwnerReference) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{5}
}</span>

func (x *KubernetesOwnerReference) GetApiVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ApiVersion
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *KubernetesOwnerReference) GetBlockOwnerDeletion() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BlockOwnerDeletion
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *KubernetesOwnerReference) GetController() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Controller
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *KubernetesOwnerReference) GetKind() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Kind
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *KubernetesOwnerReference) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *KubernetesOwnerReference) GetUid() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Uid
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Metadata about the client operator and Kubernetes cluster.
// Sent as the first message in each KubernetesResources RPC request stream.
type KubernetesClusterMetadata struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Unique ID of the client operator's Kubernetes cluster.
        // This is the UID of the cluster's kube-system namespace, which is considered globally unique.
        Uid string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
        // Kubernetes version of the operator's cluster.
        // https://pkg.go.dev/k8s.io/client-go/discovery#DiscoveryClient.ServerVersion
        KubernetesVersion string `protobuf:"bytes,2,opt,name=kubernetes_version,json=kubernetesVersion,proto3" json:"kubernetes_version,omitempty"`
        // Version of the operator. This version is following the Semver 2.0.0 format, e.g. "1.2.0".
        // https://semver.org/spec/v2.0.0.html
        OperatorVersion string `protobuf:"bytes,3,opt,name=operator_version,json=operatorVersion,proto3" json:"operator_version,omitempty"`
        // The network flow collection mechanism configured in the operator's cluster
        FlowCollector FlowCollector `protobuf:"varint,4,opt,name=flow_collector,json=flowCollector,proto3,enum=illumio.cloud.k8sclustersync.v1.FlowCollector" json:"flow_collector,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *KubernetesClusterMetadata) Reset() <span class="cov0" title="0">{
        *x = KubernetesClusterMetadata{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *KubernetesClusterMetadata) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*KubernetesClusterMetadata) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *KubernetesClusterMetadata) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use KubernetesClusterMetadata.ProtoReflect.Descriptor instead.
func (*KubernetesClusterMetadata) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{6}
}</span>

func (x *KubernetesClusterMetadata) GetUid() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Uid
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *KubernetesClusterMetadata) GetKubernetesVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.KubernetesVersion
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *KubernetesClusterMetadata) GetOperatorVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OperatorVersion
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *KubernetesClusterMetadata) GetFlowCollector() FlowCollector <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FlowCollector
        }</span>
        <span class="cov0" title="0">return FlowCollector_FLOW_COLLECTOR_UNSPECIFIED</span>
}

// Message sent by the operator in a KubernetesResources request stream.
// Message subtypes are sent in this order in each stream:
// 1. (1) cluster_metadata, to identify the client cluster and operator.
// 2. (0+) resource_metadata, one message for each resource in the cluster.
// 3. (1) resource_snapshot_complete, to indicate the initial snapshot of all resources in the cluster is complete.
// 4. (0+) resource_mutation, one message for each resource creation/update/deletion in the cluster.
type SendKubernetesResourcesRequest struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Send any of these "request" messages that can contain any of the documented types.
        //
        // Types that are valid to be assigned to Request:
        //
        //        *SendKubernetesResourcesRequest_Keepalive
        //        *SendKubernetesResourcesRequest_ClusterMetadata
        //        *SendKubernetesResourcesRequest_ResourceData
        //        *SendKubernetesResourcesRequest_ResourceSnapshotComplete
        //        *SendKubernetesResourcesRequest_KubernetesResourceMutation
        Request       isSendKubernetesResourcesRequest_Request `protobuf_oneof:"request"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SendKubernetesResourcesRequest) Reset() <span class="cov0" title="0">{
        *x = SendKubernetesResourcesRequest{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SendKubernetesResourcesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SendKubernetesResourcesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SendKubernetesResourcesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SendKubernetesResourcesRequest.ProtoReflect.Descriptor instead.
func (*SendKubernetesResourcesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{7}
}</span>

func (x *SendKubernetesResourcesRequest) GetRequest() isSendKubernetesResourcesRequest_Request <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Request
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SendKubernetesResourcesRequest) GetKeepalive() *Keepalive <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Request.(*SendKubernetesResourcesRequest_Keepalive); ok </span><span class="cov0" title="0">{
                        return x.Keepalive
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (x *SendKubernetesResourcesRequest) GetClusterMetadata() *KubernetesClusterMetadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Request.(*SendKubernetesResourcesRequest_ClusterMetadata); ok </span><span class="cov0" title="0">{
                        return x.ClusterMetadata
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (x *SendKubernetesResourcesRequest) GetResourceData() *KubernetesObjectData <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Request.(*SendKubernetesResourcesRequest_ResourceData); ok </span><span class="cov0" title="0">{
                        return x.ResourceData
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (x *SendKubernetesResourcesRequest) GetResourceSnapshotComplete() *KubernetesResourceSnapshotComplete <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Request.(*SendKubernetesResourcesRequest_ResourceSnapshotComplete); ok </span><span class="cov0" title="0">{
                        return x.ResourceSnapshotComplete
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (x *SendKubernetesResourcesRequest) GetKubernetesResourceMutation() *KubernetesResourceMutation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Request.(*SendKubernetesResourcesRequest_KubernetesResourceMutation); ok </span><span class="cov0" title="0">{
                        return x.KubernetesResourceMutation
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type isSendKubernetesResourcesRequest_Request interface {
        isSendKubernetesResourcesRequest_Request()
}

type SendKubernetesResourcesRequest_Keepalive struct {
        Keepalive *Keepalive `protobuf:"bytes,5,opt,name=keepalive,proto3,oneof"`
}

type SendKubernetesResourcesRequest_ClusterMetadata struct {
        // Metadata about the cluster and operator.
        ClusterMetadata *KubernetesClusterMetadata `protobuf:"bytes,1,opt,name=cluster_metadata,json=clusterMetadata,proto3,oneof"`
}

type SendKubernetesResourcesRequest_ResourceData struct {
        // Metadata about a Kubernetes resource in the cluster.
        ResourceData *KubernetesObjectData `protobuf:"bytes,2,opt,name=resource_data,json=resourceData,proto3,oneof"`
}

type SendKubernetesResourcesRequest_ResourceSnapshotComplete struct {
        // Indicates that all resource_metadata have been sent to report all the resources in the cluster in the initial snapshot.
        ResourceSnapshotComplete *KubernetesResourceSnapshotComplete `protobuf:"bytes,3,opt,name=resource_snapshot_complete,json=resourceSnapshotComplete,proto3,oneof"`
}

type SendKubernetesResourcesRequest_KubernetesResourceMutation struct {
        // A mutation to a Kubernetes resource in the cluster.
        KubernetesResourceMutation *KubernetesResourceMutation `protobuf:"bytes,4,opt,name=kubernetes_resource_mutation,json=kubernetesResourceMutation,proto3,oneof"`
}

func (*SendKubernetesResourcesRequest_Keepalive) isSendKubernetesResourcesRequest_Request() {<span class="cov0" title="0">}</span>

func (*SendKubernetesResourcesRequest_ClusterMetadata) isSendKubernetesResourcesRequest_Request() {<span class="cov0" title="0">}</span>

func (*SendKubernetesResourcesRequest_ResourceData) isSendKubernetesResourcesRequest_Request() {<span class="cov0" title="0">}</span>

func (*SendKubernetesResourcesRequest_ResourceSnapshotComplete) isSendKubernetesResourcesRequest_Request() {<span class="cov0" title="0">
}</span>

func (*SendKubernetesResourcesRequest_KubernetesResourceMutation) isSendKubernetesResourcesRequest_Request() {<span class="cov0" title="0">
}</span>

// Empty on purpose since this type is just expected when snapshot stream is done.
type KubernetesResourceSnapshotComplete struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *KubernetesResourceSnapshotComplete) Reset() <span class="cov0" title="0">{
        *x = KubernetesResourceSnapshotComplete{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *KubernetesResourceSnapshotComplete) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*KubernetesResourceSnapshotComplete) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *KubernetesResourceSnapshotComplete) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use KubernetesResourceSnapshotComplete.ProtoReflect.Descriptor instead.
func (*KubernetesResourceSnapshotComplete) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{8}
}</span>

// Message sent to the operator in a KubernetesResources response stream.
type SendKubernetesResourcesResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SendKubernetesResourcesResponse) Reset() <span class="cov0" title="0">{
        *x = SendKubernetesResourcesResponse{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SendKubernetesResourcesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SendKubernetesResourcesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SendKubernetesResourcesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SendKubernetesResourcesResponse.ProtoReflect.Descriptor instead.
func (*SendKubernetesResourcesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{9}
}</span>

// A mutation to a Kubernetes resource in the cluster.
// Each mutation contains the full resource metadata after mutation (on create or update)
// or before mutation (on delete).
type KubernetesResourceMutation struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Send any of these "mutation" messages that can contain any of
        // The documented types
        //
        // Types that are valid to be assigned to Mutation:
        //
        //        *KubernetesResourceMutation_CreateResource
        //        *KubernetesResourceMutation_UpdateResource
        //        *KubernetesResourceMutation_DeleteResource
        Mutation      isKubernetesResourceMutation_Mutation `protobuf_oneof:"mutation"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *KubernetesResourceMutation) Reset() <span class="cov0" title="0">{
        *x = KubernetesResourceMutation{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *KubernetesResourceMutation) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*KubernetesResourceMutation) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *KubernetesResourceMutation) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use KubernetesResourceMutation.ProtoReflect.Descriptor instead.
func (*KubernetesResourceMutation) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{10}
}</span>

func (x *KubernetesResourceMutation) GetMutation() isKubernetesResourceMutation_Mutation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Mutation
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *KubernetesResourceMutation) GetCreateResource() *KubernetesObjectData <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Mutation.(*KubernetesResourceMutation_CreateResource); ok </span><span class="cov0" title="0">{
                        return x.CreateResource
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (x *KubernetesResourceMutation) GetUpdateResource() *KubernetesObjectData <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Mutation.(*KubernetesResourceMutation_UpdateResource); ok </span><span class="cov0" title="0">{
                        return x.UpdateResource
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (x *KubernetesResourceMutation) GetDeleteResource() *KubernetesObjectData <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Mutation.(*KubernetesResourceMutation_DeleteResource); ok </span><span class="cov0" title="0">{
                        return x.DeleteResource
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type isKubernetesResourceMutation_Mutation interface {
        isKubernetesResourceMutation_Mutation()
}

type KubernetesResourceMutation_CreateResource struct {
        // Metadata of a newly created Kubernetes resource.
        CreateResource *KubernetesObjectData `protobuf:"bytes,1,opt,name=create_resource,json=createResource,proto3,oneof"`
}

type KubernetesResourceMutation_UpdateResource struct {
        // Metadata of an updated Kubernetes resource, after update.
        UpdateResource *KubernetesObjectData `protobuf:"bytes,2,opt,name=update_resource,json=updateResource,proto3,oneof"`
}

type KubernetesResourceMutation_DeleteResource struct {
        // Metadata of a deleted Kubernetes resource, before deletion.
        DeleteResource *KubernetesObjectData `protobuf:"bytes,3,opt,name=delete_resource,json=deleteResource,proto3,oneof"`
}

func (*KubernetesResourceMutation_CreateResource) isKubernetesResourceMutation_Mutation() {<span class="cov0" title="0">}</span>

func (*KubernetesResourceMutation_UpdateResource) isKubernetesResourceMutation_Mutation() {<span class="cov0" title="0">}</span>

func (*KubernetesResourceMutation_DeleteResource) isKubernetesResourceMutation_Mutation() {<span class="cov0" title="0">}</span>

// A flow received from Falco using custom rules
type FalcoFlow struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // layer3 IP layer, source, destination and ip_version
        Layer3 *IP `protobuf:"bytes,1,opt,name=layer3,proto3" json:"layer3,omitempty"`
        // Proto contains protocol used
        Layer4 *Layer4 `protobuf:"bytes,2,opt,name=layer4,proto3" json:"layer4,omitempty"`
        // Types that are valid to be assigned to Ts:
        //
        //        *FalcoFlow_Time
        //        *FalcoFlow_Timestamp
        Ts            isFalcoFlow_Ts `protobuf_oneof:"ts"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *FalcoFlow) Reset() <span class="cov0" title="0">{
        *x = FalcoFlow{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *FalcoFlow) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FalcoFlow) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FalcoFlow) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FalcoFlow.ProtoReflect.Descriptor instead.
func (*FalcoFlow) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{11}
}</span>

func (x *FalcoFlow) GetLayer3() *IP <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Layer3
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FalcoFlow) GetLayer4() *Layer4 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Layer4
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FalcoFlow) GetTs() isFalcoFlow_Ts <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ts
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Deprecated: Marked as deprecated in illumio/cloud/k8sclustersync/v1/k8s_info.proto.
func (x *FalcoFlow) GetTime() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Ts.(*FalcoFlow_Time); ok </span><span class="cov0" title="0">{
                        return x.Time
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func (x *FalcoFlow) GetTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Ts.(*FalcoFlow_Timestamp); ok </span><span class="cov0" title="0">{
                        return x.Timestamp
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type isFalcoFlow_Ts interface {
        isFalcoFlow_Ts()
}

type FalcoFlow_Time struct {
        // time contains the unparsed timestamp string received from Falco; parse it and set timestamp instead
        //
        // Deprecated: Marked as deprecated in illumio/cloud/k8sclustersync/v1/k8s_info.proto.
        Time string `protobuf:"bytes,3,opt,name=time,proto3,oneof"`
}

type FalcoFlow_Timestamp struct {
        Timestamp *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=timestamp,proto3,oneof"`
}

func (*FalcoFlow_Time) isFalcoFlow_Ts() {<span class="cov0" title="0">}</span>

func (*FalcoFlow_Timestamp) isFalcoFlow_Ts() {<span class="cov0" title="0">}</span>

// A flow received from Cilium Hubble Relay using the Observer service's GetFlows RPC.
// https://github.com/cilium/cilium/blob/main/api/v1/observer/observer.proto
type CiliumFlow struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Time when flow occurred.
        Time *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=time,proto3" json:"time,omitempty"`
        // node_name is the name of the node from which this Flow was captured.
        NodeName string `protobuf:"bytes,2,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
        // traffic_direction distinguishes direction of the connection, e.g. ingress or egress.
        TrafficDirection TrafficDirection `protobuf:"varint,3,opt,name=traffic_direction,json=trafficDirection,proto3,enum=illumio.cloud.k8sclustersync.v1.TrafficDirection" json:"traffic_direction,omitempty"`
        // verdict of the flow, indicating the outcome of the network packet processing.
        Verdict Verdict `protobuf:"varint,4,opt,name=verdict,proto3,enum=illumio.cloud.k8sclustersync.v1.Verdict" json:"verdict,omitempty"`
        // layer3 IP layer, source, destination and ip_version
        Layer3 *IP `protobuf:"bytes,5,opt,name=layer3,proto3" json:"layer3,omitempty"`
        // layer4 contains protocol used
        Layer4 *Layer4 `protobuf:"bytes,6,opt,name=layer4,proto3" json:"layer4,omitempty"`
        // is_reply indicates that this was a packet (L4) or message (L7) in the
        // reply direction. May be absent (in which case it is unknown whether it
        // is a reply or not).
        IsReply *wrapperspb.BoolValue `protobuf:"bytes,7,opt,name=is_reply,json=isReply,proto3" json:"is_reply,omitempty"`
        // endpoint of source ip with metadata
        SourceEndpoint *Endpoint `protobuf:"bytes,8,opt,name=source_endpoint,json=sourceEndpoint,proto3,oneof" json:"source_endpoint,omitempty"`
        // endpoint of destination ip with metadata
        DestinationEndpoint *Endpoint `protobuf:"bytes,9,opt,name=destination_endpoint,json=destinationEndpoint,proto3,oneof" json:"destination_endpoint,omitempty"`
        // destination_service contains the service name of the destination
        DestinationService *Service `protobuf:"bytes,10,opt,name=destination_service,json=destinationService,proto3" json:"destination_service,omitempty"`
        // The CiliumNetworkPolicies allowing the egress of the flow.
        EgressAllowedBy []*Policy `protobuf:"bytes,11,rep,name=egress_allowed_by,json=egressAllowedBy,proto3" json:"egress_allowed_by,omitempty"`
        // The CiliumNetworkPolicies allowing the ingress of the flow.
        IngressAllowedBy []*Policy `protobuf:"bytes,12,rep,name=ingress_allowed_by,json=ingressAllowedBy,proto3" json:"ingress_allowed_by,omitempty"`
        // The CiliumNetworkPolicies denying the egress of the flow.
        EgressDeniedBy []*Policy `protobuf:"bytes,13,rep,name=egress_denied_by,json=egressDeniedBy,proto3" json:"egress_denied_by,omitempty"`
        // The CiliumNetworkPolicies denying the ingress of the flow.
        IngressDeniedBy []*Policy `protobuf:"bytes,14,rep,name=ingress_denied_by,json=ingressDeniedBy,proto3" json:"ingress_denied_by,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *CiliumFlow) Reset() <span class="cov0" title="0">{
        *x = CiliumFlow{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CiliumFlow) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CiliumFlow) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CiliumFlow) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CiliumFlow.ProtoReflect.Descriptor instead.
func (*CiliumFlow) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{12}
}</span>

func (x *CiliumFlow) GetTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Time
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CiliumFlow) GetNodeName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NodeName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CiliumFlow) GetTrafficDirection() TrafficDirection <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TrafficDirection
        }</span>
        <span class="cov0" title="0">return TrafficDirection_TRAFFIC_DIRECTION_TRAFFIC_DIRECTION_UNKNOWN_UNSPECIFIED</span>
}

func (x *CiliumFlow) GetVerdict() Verdict <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Verdict
        }</span>
        <span class="cov0" title="0">return Verdict_VERDICT_UNKNOWN_UNSPECIFIED</span>
}

func (x *CiliumFlow) GetLayer3() *IP <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Layer3
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CiliumFlow) GetLayer4() *Layer4 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Layer4
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CiliumFlow) GetIsReply() *wrapperspb.BoolValue <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsReply
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CiliumFlow) GetSourceEndpoint() *Endpoint <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SourceEndpoint
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CiliumFlow) GetDestinationEndpoint() *Endpoint <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DestinationEndpoint
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CiliumFlow) GetDestinationService() *Service <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DestinationService
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CiliumFlow) GetEgressAllowedBy() []*Policy <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EgressAllowedBy
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CiliumFlow) GetIngressAllowedBy() []*Policy <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IngressAllowedBy
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CiliumFlow) GetEgressDeniedBy() []*Policy <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EgressDeniedBy
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CiliumFlow) GetIngressDeniedBy() []*Policy <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IngressDeniedBy
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Service contains Service header fields of a flow.
// https://pkg.go.dev/github.com/cilium/cilium/api/v1/flow#Service
type Service struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Namespace     string                 `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Service) Reset() <span class="cov0" title="0">{
        *x = Service{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Service) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Service) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Service) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Service.ProtoReflect.Descriptor instead.
func (*Service) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{13}
}</span>

func (x *Service) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Service) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// IP contains the IP header fields of a flow.
// https://pkg.go.dev/github.com/cilium/cilium/api/v1/flow#readme-ip
type IP struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Source        string                 `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
        Destination   string                 `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
        IpVersion     IPVersion              `protobuf:"varint,3,opt,name=ip_version,json=ipVersion,proto3,enum=illumio.cloud.k8sclustersync.v1.IPVersion" json:"ip_version,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *IP) Reset() <span class="cov0" title="0">{
        *x = IP{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *IP) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*IP) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *IP) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use IP.ProtoReflect.Descriptor instead.
func (*IP) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{14}
}</span>

func (x *IP) GetSource() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Source
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *IP) GetDestination() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Destination
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *IP) GetIpVersion() IPVersion <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IpVersion
        }</span>
        <span class="cov0" title="0">return IPVersion_IP_VERSION_IP_NOT_USED_UNSPECIFIED</span>
}

// Layer4 contains the Layer-4 header fields of a flow.
// https://pkg.go.dev/github.com/cilium/cilium/api/v1/flow#readme-layer4
type Layer4 struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Types that are valid to be assigned to Protocol:
        //
        //        *Layer4_Tcp
        //        *Layer4_Udp
        //        *Layer4_Icmpv4
        //        *Layer4_Icmpv6
        //        *Layer4_Sctp
        Protocol      isLayer4_Protocol `protobuf_oneof:"protocol"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Layer4) Reset() <span class="cov0" title="0">{
        *x = Layer4{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Layer4) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Layer4) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Layer4) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Layer4.ProtoReflect.Descriptor instead.
func (*Layer4) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{15}
}</span>

func (x *Layer4) GetProtocol() isLayer4_Protocol <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Protocol
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Layer4) GetTcp() *TCP <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Protocol.(*Layer4_Tcp); ok </span><span class="cov0" title="0">{
                        return x.Tcp
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (x *Layer4) GetUdp() *UDP <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Protocol.(*Layer4_Udp); ok </span><span class="cov0" title="0">{
                        return x.Udp
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (x *Layer4) GetIcmpv4() *ICMPv4 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Protocol.(*Layer4_Icmpv4); ok </span><span class="cov0" title="0">{
                        return x.Icmpv4
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (x *Layer4) GetIcmpv6() *ICMPv6 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Protocol.(*Layer4_Icmpv6); ok </span><span class="cov0" title="0">{
                        return x.Icmpv6
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (x *Layer4) GetSctp() *SCTP <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Protocol.(*Layer4_Sctp); ok </span><span class="cov0" title="0">{
                        return x.Sctp
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type isLayer4_Protocol interface {
        isLayer4_Protocol()
}

type Layer4_Tcp struct {
        Tcp *TCP `protobuf:"bytes,1,opt,name=tcp,proto3,oneof"`
}

type Layer4_Udp struct {
        Udp *UDP `protobuf:"bytes,2,opt,name=udp,proto3,oneof"`
}

type Layer4_Icmpv4 struct {
        // ICMP is technically not L4, but mutually exclusive with the above.
        Icmpv4 *ICMPv4 `protobuf:"bytes,3,opt,name=icmpv4,proto3,oneof"`
}

type Layer4_Icmpv6 struct {
        Icmpv6 *ICMPv6 `protobuf:"bytes,4,opt,name=icmpv6,proto3,oneof"`
}

type Layer4_Sctp struct {
        Sctp *SCTP `protobuf:"bytes,5,opt,name=sctp,proto3,oneof"`
}

func (*Layer4_Tcp) isLayer4_Protocol() {<span class="cov0" title="0">}</span>

func (*Layer4_Udp) isLayer4_Protocol() {<span class="cov0" title="0">}</span>

func (*Layer4_Icmpv4) isLayer4_Protocol() {<span class="cov0" title="0">}</span>

func (*Layer4_Icmpv6) isLayer4_Protocol() {<span class="cov0" title="0">}</span>

func (*Layer4_Sctp) isLayer4_Protocol() {<span class="cov0" title="0">}</span>

// TCP contains the TCP header fields of a flow.
// https://pkg.go.dev/github.com/cilium/cilium/api/v1/flow#readme-tcp
type TCP struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        SourcePort      uint32                 `protobuf:"varint,1,opt,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`
        DestinationPort uint32                 `protobuf:"varint,2,opt,name=destination_port,json=destinationPort,proto3" json:"destination_port,omitempty"`
        Flags           *TCPFlags              `protobuf:"bytes,3,opt,name=flags,proto3" json:"flags,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *TCP) Reset() <span class="cov0" title="0">{
        *x = TCP{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TCP) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TCP) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TCP) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TCP.ProtoReflect.Descriptor instead.
func (*TCP) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{16}
}</span>

func (x *TCP) GetSourcePort() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SourcePort
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TCP) GetDestinationPort() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DestinationPort
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TCP) GetFlags() *TCPFlags <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Flags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// TCPFlags is the mask of TCP header flags observed in TCP packets in a flow.
// https://pkg.go.dev/github.com/cilium/cilium/api/v1/flow#readme-tcpflags
type TCPFlags struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Fin           bool                   `protobuf:"varint,1,opt,name=fin,proto3" json:"fin,omitempty"`
        Syn           bool                   `protobuf:"varint,2,opt,name=syn,proto3" json:"syn,omitempty"`
        Rst           bool                   `protobuf:"varint,3,opt,name=rst,proto3" json:"rst,omitempty"`
        Psh           bool                   `protobuf:"varint,4,opt,name=psh,proto3" json:"psh,omitempty"`
        Ack           bool                   `protobuf:"varint,5,opt,name=ack,proto3" json:"ack,omitempty"`
        Urg           bool                   `protobuf:"varint,6,opt,name=urg,proto3" json:"urg,omitempty"`
        Ece           bool                   `protobuf:"varint,7,opt,name=ece,proto3" json:"ece,omitempty"`
        Cwr           bool                   `protobuf:"varint,8,opt,name=cwr,proto3" json:"cwr,omitempty"`
        Ns            bool                   `protobuf:"varint,9,opt,name=ns,proto3" json:"ns,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *TCPFlags) Reset() <span class="cov0" title="0">{
        *x = TCPFlags{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[17]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TCPFlags) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TCPFlags) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TCPFlags) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[17]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TCPFlags.ProtoReflect.Descriptor instead.
func (*TCPFlags) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{17}
}</span>

func (x *TCPFlags) GetFin() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Fin
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TCPFlags) GetSyn() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Syn
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TCPFlags) GetRst() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rst
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TCPFlags) GetPsh() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Psh
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TCPFlags) GetAck() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ack
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TCPFlags) GetUrg() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Urg
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TCPFlags) GetEce() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ece
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TCPFlags) GetCwr() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Cwr
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *TCPFlags) GetNs() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ns
        }</span>
        <span class="cov0" title="0">return false</span>
}

// UDP contains the UDP header fields of a flow.
// https://pkg.go.dev/github.com/cilium/cilium/api/v1/flow#readme-udp
type UDP struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        SourcePort      uint32                 `protobuf:"varint,1,opt,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`
        DestinationPort uint32                 `protobuf:"varint,2,opt,name=destination_port,json=destinationPort,proto3" json:"destination_port,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *UDP) Reset() <span class="cov0" title="0">{
        *x = UDP{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[18]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UDP) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UDP) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UDP) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[18]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UDP.ProtoReflect.Descriptor instead.
func (*UDP) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{18}
}</span>

func (x *UDP) GetSourcePort() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SourcePort
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UDP) GetDestinationPort() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DestinationPort
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// SCTP contains the SCTP header fields of a flow.
// https://pkg.go.dev/github.com/cilium/cilium/api/v1/flow#readme-sctp
type SCTP struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        SourcePort      uint32                 `protobuf:"varint,1,opt,name=source_port,json=sourcePort,proto3" json:"source_port,omitempty"`
        DestinationPort uint32                 `protobuf:"varint,2,opt,name=destination_port,json=destinationPort,proto3" json:"destination_port,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *SCTP) Reset() <span class="cov0" title="0">{
        *x = SCTP{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[19]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SCTP) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SCTP) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SCTP) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[19]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SCTP.ProtoReflect.Descriptor instead.
func (*SCTP) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{19}
}</span>

func (x *SCTP) GetSourcePort() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SourcePort
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SCTP) GetDestinationPort() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DestinationPort
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// ICMPv4 contains the ICMPv4 header fields of a flow.
// https://pkg.go.dev/github.com/cilium/cilium/api/v1/flow#readme-icmpv4
type ICMPv4 struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Type          uint32                 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
        Code          uint32                 `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ICMPv4) Reset() <span class="cov0" title="0">{
        *x = ICMPv4{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[20]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ICMPv4) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ICMPv4) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ICMPv4) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[20]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ICMPv4.ProtoReflect.Descriptor instead.
func (*ICMPv4) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{20}
}</span>

func (x *ICMPv4) GetType() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ICMPv4) GetCode() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// ICMPv6 contains the ICMPv6 header fields of a flow.
// https://pkg.go.dev/github.com/cilium/cilium/api/v1/flow#readme-icmpv6
type ICMPv6 struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Type          uint32                 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
        Code          uint32                 `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ICMPv6) Reset() <span class="cov0" title="0">{
        *x = ICMPv6{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[21]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ICMPv6) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ICMPv6) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ICMPv6) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[21]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ICMPv6.ProtoReflect.Descriptor instead.
func (*ICMPv6) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{21}
}</span>

func (x *ICMPv6) GetType() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ICMPv6) GetCode() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Endpoint contains the Endpoint header fields of a flow
// https://pkg.go.dev/github.com/cilium/cilium/api/v1/flow#readme-endpoint
type Endpoint struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Uid           uint32                 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
        ClusterName   string                 `protobuf:"bytes,7,opt,name=cluster_name,json=clusterName,proto3" json:"cluster_name,omitempty"`
        Namespace     string                 `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
        Labels        []string               `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty"`
        PodName       string                 `protobuf:"bytes,5,opt,name=pod_name,json=podName,proto3" json:"pod_name,omitempty"`
        Workloads     []*Workload            `protobuf:"bytes,6,rep,name=workloads,proto3" json:"workloads,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Endpoint) Reset() <span class="cov0" title="0">{
        *x = Endpoint{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[22]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Endpoint) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Endpoint) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Endpoint) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[22]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Endpoint.ProtoReflect.Descriptor instead.
func (*Endpoint) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{22}
}</span>

func (x *Endpoint) GetUid() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Uid
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Endpoint) GetClusterName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ClusterName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Endpoint) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Endpoint) GetLabels() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Labels
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Endpoint) GetPodName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PodName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Endpoint) GetWorkloads() []*Workload <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Workloads
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Workload contains the Workload header fields of a flow
// https://pkg.go.dev/github.com/cilium/cilium/api/v1/flow#readme-workload
type Workload struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Kind          string                 `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Workload) Reset() <span class="cov0" title="0">{
        *x = Workload{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[23]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Workload) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Workload) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Workload) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[23]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Workload.ProtoReflect.Descriptor instead.
func (*Workload) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{23}
}</span>

func (x *Workload) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Workload) GetKind() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Kind
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Policy contains the Policy header fields of a flow.
// https://pkg.go.dev/github.com/cilium/cilium/api/v1/flow#readme-policy
type Policy struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Namespace     string                 `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
        Labels        []string               `protobuf:"bytes,3,rep,name=labels,proto3" json:"labels,omitempty"`
        Revision      uint64                 `protobuf:"varint,4,opt,name=revision,proto3" json:"revision,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Policy) Reset() <span class="cov0" title="0">{
        *x = Policy{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[24]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Policy) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Policy) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Policy) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[24]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Policy.ProtoReflect.Descriptor instead.
func (*Policy) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{24}
}</span>

func (x *Policy) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Policy) GetNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Policy) GetLabels() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Labels
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Policy) GetRevision() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Revision
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Flow exported by the CNI plugin in the cluster.
type SendKubernetesNetworkFlowsRequest struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Types that are valid to be assigned to Request:
        //
        //        *SendKubernetesNetworkFlowsRequest_Keepalive
        //        *SendKubernetesNetworkFlowsRequest_CiliumFlow
        //        *SendKubernetesNetworkFlowsRequest_FalcoFlow
        Request       isSendKubernetesNetworkFlowsRequest_Request `protobuf_oneof:"request"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SendKubernetesNetworkFlowsRequest) Reset() <span class="cov0" title="0">{
        *x = SendKubernetesNetworkFlowsRequest{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[25]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SendKubernetesNetworkFlowsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SendKubernetesNetworkFlowsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SendKubernetesNetworkFlowsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[25]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SendKubernetesNetworkFlowsRequest.ProtoReflect.Descriptor instead.
func (*SendKubernetesNetworkFlowsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{25}
}</span>

func (x *SendKubernetesNetworkFlowsRequest) GetRequest() isSendKubernetesNetworkFlowsRequest_Request <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Request
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SendKubernetesNetworkFlowsRequest) GetKeepalive() *Keepalive <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Request.(*SendKubernetesNetworkFlowsRequest_Keepalive); ok </span><span class="cov0" title="0">{
                        return x.Keepalive
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (x *SendKubernetesNetworkFlowsRequest) GetCiliumFlow() *CiliumFlow <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Request.(*SendKubernetesNetworkFlowsRequest_CiliumFlow); ok </span><span class="cov0" title="0">{
                        return x.CiliumFlow
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (x *SendKubernetesNetworkFlowsRequest) GetFalcoFlow() *FalcoFlow <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Request.(*SendKubernetesNetworkFlowsRequest_FalcoFlow); ok </span><span class="cov0" title="0">{
                        return x.FalcoFlow
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type isSendKubernetesNetworkFlowsRequest_Request interface {
        isSendKubernetesNetworkFlowsRequest_Request()
}

type SendKubernetesNetworkFlowsRequest_Keepalive struct {
        Keepalive *Keepalive `protobuf:"bytes,3,opt,name=keepalive,proto3,oneof"`
}

type SendKubernetesNetworkFlowsRequest_CiliumFlow struct {
        CiliumFlow *CiliumFlow `protobuf:"bytes,1,opt,name=cilium_flow,json=ciliumFlow,proto3,oneof"`
}

type SendKubernetesNetworkFlowsRequest_FalcoFlow struct {
        FalcoFlow *FalcoFlow `protobuf:"bytes,2,opt,name=falco_flow,json=falcoFlow,proto3,oneof"`
}

func (*SendKubernetesNetworkFlowsRequest_Keepalive) isSendKubernetesNetworkFlowsRequest_Request() {<span class="cov0" title="0">}</span>

func (*SendKubernetesNetworkFlowsRequest_CiliumFlow) isSendKubernetesNetworkFlowsRequest_Request() {<span class="cov0" title="0">}</span>

func (*SendKubernetesNetworkFlowsRequest_FalcoFlow) isSendKubernetesNetworkFlowsRequest_Request() {<span class="cov0" title="0">}</span>

// Message sent to the operator in a SendKubernetesNetworkFlows response stream.
type SendKubernetesNetworkFlowsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SendKubernetesNetworkFlowsResponse) Reset() <span class="cov0" title="0">{
        *x = SendKubernetesNetworkFlowsResponse{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[26]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SendKubernetesNetworkFlowsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SendKubernetesNetworkFlowsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SendKubernetesNetworkFlowsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[26]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SendKubernetesNetworkFlowsResponse.ProtoReflect.Descriptor instead.
func (*SendKubernetesNetworkFlowsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{26}
}</span>

// Message representing a log entry.
type LogEntry struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // The actual log message contents, as a JSON object.
        JsonMessage   string `protobuf:"bytes,3,opt,name=json_message,json=jsonMessage,proto3" json:"json_message,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LogEntry) Reset() <span class="cov0" title="0">{
        *x = LogEntry{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[27]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LogEntry) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogEntry) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogEntry) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[27]
        if x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogEntry.ProtoReflect.Descriptor instead.
func (*LogEntry) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{27}
}</span>

func (x *LogEntry) GetJsonMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.JsonMessage
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Message to encapsulate a request to send logs.
type SendLogsRequest struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Types that are valid to be assigned to Request:
        //
        //        *SendLogsRequest_Keepalive
        //        *SendLogsRequest_LogEntry
        Request       isSendLogsRequest_Request `protobuf_oneof:"request"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SendLogsRequest) Reset() <span class="cov0" title="0">{
        *x = SendLogsRequest{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[28]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SendLogsRequest) String() string <span class="cov8" title="1">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SendLogsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SendLogsRequest) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[28]
        if x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SendLogsRequest.ProtoReflect.Descriptor instead.
func (*SendLogsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{28}
}</span>

func (x *SendLogsRequest) GetRequest() isSendLogsRequest_Request <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Request
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SendLogsRequest) GetKeepalive() *Keepalive <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Request.(*SendLogsRequest_Keepalive); ok </span><span class="cov0" title="0">{
                        return x.Keepalive
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (x *SendLogsRequest) GetLogEntry() *LogEntry <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Request.(*SendLogsRequest_LogEntry); ok </span><span class="cov0" title="0">{
                        return x.LogEntry
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type isSendLogsRequest_Request interface {
        isSendLogsRequest_Request()
}

type SendLogsRequest_Keepalive struct {
        Keepalive *Keepalive `protobuf:"bytes,2,opt,name=keepalive,proto3,oneof"`
}

type SendLogsRequest_LogEntry struct {
        // A single log entry to be sent.
        LogEntry *LogEntry `protobuf:"bytes,1,opt,name=log_entry,json=logEntry,proto3,oneof"`
}

func (*SendLogsRequest_Keepalive) isSendLogsRequest_Request() {<span class="cov0" title="0">}</span>

func (*SendLogsRequest_LogEntry) isSendLogsRequest_Request() {<span class="cov0" title="0">}</span>

// Message to encapsulate setting the log level.
type SetLogLevel struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // The log level to be set in the operator.
        Level         LogLevel `protobuf:"varint,1,opt,name=level,proto3,enum=illumio.cloud.k8sclustersync.v1.LogLevel" json:"level,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SetLogLevel) Reset() <span class="cov0" title="0">{
        *x = SetLogLevel{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[29]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SetLogLevel) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SetLogLevel) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SetLogLevel) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[29]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SetLogLevel.ProtoReflect.Descriptor instead.
func (*SetLogLevel) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{29}
}</span>

func (x *SetLogLevel) GetLevel() LogLevel <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Level
        }</span>
        <span class="cov0" title="0">return LogLevel_LOG_LEVEL_UNSPECIFIED</span>
}

// Message to encapsulate the response for sending logs.
type SendLogsResponse struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // Types that are valid to be assigned to Response:
        //
        //        *SendLogsResponse_SetLogLevel
        Response      isSendLogsResponse_Response `protobuf_oneof:"response"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SendLogsResponse) Reset() <span class="cov0" title="0">{
        *x = SendLogsResponse{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[30]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SendLogsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SendLogsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SendLogsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[30]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SendLogsResponse.ProtoReflect.Descriptor instead.
func (*SendLogsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{30}
}</span>

func (x *SendLogsResponse) GetResponse() isSendLogsResponse_Response <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Response
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SendLogsResponse) GetSetLogLevel() *SetLogLevel <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                if x, ok := x.Response.(*SendLogsResponse_SetLogLevel); ok </span><span class="cov0" title="0">{
                        return x.SetLogLevel
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type isSendLogsResponse_Response interface {
        isSendLogsResponse_Response()
}

type SendLogsResponse_SetLogLevel struct {
        // set_log_level sets the operator's log level to the given level.
        SetLogLevel *SetLogLevel `protobuf:"bytes,1,opt,name=set_log_level,json=setLogLevel,proto3,oneof"`
}

func (*SendLogsResponse_SetLogLevel) isSendLogsResponse_Response() {<span class="cov0" title="0">}</span>

type KubernetesServiceData_ServicePort struct {
        state protoimpl.MessageState `protogen:"open.v1"`
        // The port on each node on which this service is exposed
        NodePort *uint32 `protobuf:"varint,1,opt,name=node_port,json=nodePort,proto3,oneof" json:"node_port,omitempty"`
        // The port that will be exposed by this service
        Port uint32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
        // The IP protocol for this port, supports "TCP", "UDP", and "SCTP"
        Protocol string `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty"`
        // List of ports exposing the service via a load balancer
        LoadBalancerPorts []string `protobuf:"bytes,4,rep,name=load_balancer_ports,json=loadBalancerPorts,proto3" json:"load_balancer_ports,omitempty"`
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *KubernetesServiceData_ServicePort) Reset() <span class="cov0" title="0">{
        *x = KubernetesServiceData_ServicePort{}
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[33]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *KubernetesServiceData_ServicePort) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*KubernetesServiceData_ServicePort) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *KubernetesServiceData_ServicePort) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[33]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use KubernetesServiceData_ServicePort.ProtoReflect.Descriptor instead.
func (*KubernetesServiceData_ServicePort) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP(), []int{2, 0}
}</span>

func (x *KubernetesServiceData_ServicePort) GetNodePort() uint32 <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.NodePort != nil </span><span class="cov0" title="0">{
                return *x.NodePort
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *KubernetesServiceData_ServicePort) GetPort() uint32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Port
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *KubernetesServiceData_ServicePort) GetProtocol() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Protocol
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *KubernetesServiceData_ServicePort) GetLoadBalancerPorts() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LoadBalancerPorts
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_illumio_cloud_k8sclustersync_v1_k8s_info_proto protoreflect.FileDescriptor

const file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDesc = "" +
        "\n" +
        ".illumio/cloud/k8sclustersync/v1/k8s_info.proto\x12\x1fillumio.cloud.k8sclustersync.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\v\n" +
        "\tKeepalive\"\x82\a\n" +
        "\x14KubernetesObjectData\x12h\n" +
        "\vannotations\x18\x01 \x03(\v2F.illumio.cloud.k8sclustersync.v1.KubernetesObjectData.AnnotationsEntryR\vannotations\x12I\n" +
        "\x12creation_timestamp\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\x11creationTimestamp\x12\x12\n" +
        "\x04kind\x18\x03 \x01(\tR\x04kind\x12Y\n" +
        "\x06labels\x18\x04 \x03(\v2A.illumio.cloud.k8sclustersync.v1.KubernetesObjectData.LabelsEntryR\x06labels\x12\x12\n" +
        "\x04name\x18\x05 \x01(\tR\x04name\x12\x1c\n" +
        "\tnamespace\x18\x06 \x01(\tR\tnamespace\x12d\n" +
        "\x10owner_references\x18\a \x03(\v29.illumio.cloud.k8sclustersync.v1.KubernetesOwnerReferenceR\x0fownerReferences\x12)\n" +
        "\x10resource_version\x18\b \x01(\tR\x0fresourceVersion\x12\x10\n" +
        "\x03uid\x18\t \x01(\tR\x03uid\x12F\n" +
        "\x03pod\x18d \x01(\v22.illumio.cloud.k8sclustersync.v1.KubernetesPodDataH\x00R\x03pod\x12I\n" +
        "\x04node\x18e \x01(\v23.illumio.cloud.k8sclustersync.v1.KubernetesNodeDataH\x00R\x04node\x12R\n" +
        "\aservice\x18f \x01(\v26.illumio.cloud.k8sclustersync.v1.KubernetesServiceDataH\x00R\aservice\x1a&gt;\n" +
        "\x10AnnotationsEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a9\n" +
        "\vLabelsEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\x0f\n" +
        "\rkind_specific\"\xd1\x03\n" +
        "\x15KubernetesServiceData\x12!\n" +
        "\fip_addresses\x18\x01 \x03(\tR\vipAddresses\x12X\n" +
        "\x05ports\x18\x02 \x03(\v2B.illumio.cloud.k8sclustersync.v1.KubernetesServiceData.ServicePortR\x05ports\x12\x12\n" +
        "\x04type\x18\x03 \x01(\tR\x04type\x12(\n" +
        "\rexternal_name\x18\x04 \x01(\tH\x00R\fexternalName\x88\x01\x01\x123\n" +
        "\x13load_balancer_class\x18\x05 \x01(\tH\x01R\x11loadBalancerClass\x88\x01\x01\x1a\x9d\x01\n" +
        "\vServicePort\x12 \n" +
        "\tnode_port\x18\x01 \x01(\rH\x00R\bnodePort\x88\x01\x01\x12\x12\n" +
        "\x04port\x18\x02 \x01(\rR\x04port\x12\x1a\n" +
        "\bprotocol\x18\x03 \x01(\tR\bprotocol\x12.\n" +
        "\x13load_balancer_ports\x18\x04 \x03(\tR\x11loadBalancerPortsB\f\n" +
        "\n" +
        "_node_portB\x10\n" +
        "\x0e_external_nameB\x16\n" +
        "\x14_load_balancer_class\"X\n" +
        "\x12KubernetesNodeData\x12\x1f\n" +
        "\vprovider_id\x18\x01 \x01(\tR\n" +
        "providerId\x12!\n" +
        "\fip_addresses\x18\x02 \x03(\tR\vipAddresses\"6\n" +
        "\x11KubernetesPodData\x12!\n" +
        "\fip_addresses\x18\x01 \x03(\tR\vipAddresses\"\xc7\x01\n" +
        "\x18KubernetesOwnerReference\x12\x1f\n" +
        "\vapi_version\x18\x01 \x01(\tR\n" +
        "apiVersion\x120\n" +
        "\x14block_owner_deletion\x18\x02 \x01(\bR\x12blockOwnerDeletion\x12\x1e\n" +
        "\n" +
        "controller\x18\x03 \x01(\bR\n" +
        "controller\x12\x12\n" +
        "\x04kind\x18\x04 \x01(\tR\x04kind\x12\x12\n" +
        "\x04name\x18\x05 \x01(\tR\x04name\x12\x10\n" +
        "\x03uid\x18\x06 \x01(\tR\x03uid\"\xde\x01\n" +
        "\x19KubernetesClusterMetadata\x12\x10\n" +
        "\x03uid\x18\x01 \x01(\tR\x03uid\x12-\n" +
        "\x12kubernetes_version\x18\x02 \x01(\tR\x11kubernetesVersion\x12)\n" +
        "\x10operator_version\x18\x03 \x01(\tR\x0foperatorVersion\x12U\n" +
        "\x0eflow_collector\x18\x04 \x01(\x0e2..illumio.cloud.k8sclustersync.v1.FlowCollectorR\rflowCollector\"\xc5\x04\n" +
        "\x1eSendKubernetesResourcesRequest\x12J\n" +
        "\tkeepalive\x18\x05 \x01(\v2*.illumio.cloud.k8sclustersync.v1.KeepaliveH\x00R\tkeepalive\x12g\n" +
        "\x10cluster_metadata\x18\x01 \x01(\v2:.illumio.cloud.k8sclustersync.v1.KubernetesClusterMetadataH\x00R\x0fclusterMetadata\x12\\\n" +
        "\rresource_data\x18\x02 \x01(\v25.illumio.cloud.k8sclustersync.v1.KubernetesObjectDataH\x00R\fresourceData\x12\x83\x01\n" +
        "\x1aresource_snapshot_complete\x18\x03 \x01(\v2C.illumio.cloud.k8sclustersync.v1.KubernetesResourceSnapshotCompleteH\x00R\x18resourceSnapshotComplete\x12\x7f\n" +
        "\x1ckubernetes_resource_mutation\x18\x04 \x01(\v2;.illumio.cloud.k8sclustersync.v1.KubernetesResourceMutationH\x00R\x1akubernetesResourceMutationB\t\n" +
        "\arequest\"$\n" +
        "\"KubernetesResourceSnapshotComplete\"!\n" +
        "\x1fSendKubernetesResourcesResponse\"\xce\x02\n" +
        "\x1aKubernetesResourceMutation\x12`\n" +
        "\x0fcreate_resource\x18\x01 \x01(\v25.illumio.cloud.k8sclustersync.v1.KubernetesObjectDataH\x00R\x0ecreateResource\x12`\n" +
        "\x0fupdate_resource\x18\x02 \x01(\v25.illumio.cloud.k8sclustersync.v1.KubernetesObjectDataH\x00R\x0eupdateResource\x12`\n" +
        "\x0fdelete_resource\x18\x03 \x01(\v25.illumio.cloud.k8sclustersync.v1.KubernetesObjectDataH\x00R\x0edeleteResourceB\n" +
        "\n" +
        "\bmutation\"\xe5\x01\n" +
        "\tFalcoFlow\x12;\n" +
        "\x06layer3\x18\x01 \x01(\v2#.illumio.cloud.k8sclustersync.v1.IPR\x06layer3\x12?\n" +
        "\x06layer4\x18\x02 \x01(\v2'.illumio.cloud.k8sclustersync.v1.Layer4R\x06layer4\x12\x18\n" +
        "\x04time\x18\x03 \x01(\tB\x02\x18\x01H\x00R\x04time\x12:\n" +
        "\ttimestamp\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampH\x00R\ttimestampB\x04\n" +
        "\x02ts\"\xca\b\n" +
        "\n" +
        "CiliumFlow\x12.\n" +
        "\x04time\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\x04time\x12\x1b\n" +
        "\tnode_name\x18\x02 \x01(\tR\bnodeName\x12^\n" +
        "\x11traffic_direction\x18\x03 \x01(\x0e21.illumio.cloud.k8sclustersync.v1.TrafficDirectionR\x10trafficDirection\x12B\n" +
        "\averdict\x18\x04 \x01(\x0e2(.illumio.cloud.k8sclustersync.v1.VerdictR\averdict\x12;\n" +
        "\x06layer3\x18\x05 \x01(\v2#.illumio.cloud.k8sclustersync.v1.IPR\x06layer3\x12?\n" +
        "\x06layer4\x18\x06 \x01(\v2'.illumio.cloud.k8sclustersync.v1.Layer4R\x06layer4\x125\n" +
        "\bis_reply\x18\a \x01(\v2\x1a.google.protobuf.BoolValueR\aisReply\x12W\n" +
        "\x0fsource_endpoint\x18\b \x01(\v2).illumio.cloud.k8sclustersync.v1.EndpointH\x00R\x0esourceEndpoint\x88\x01\x01\x12a\n" +
        "\x14destination_endpoint\x18\t \x01(\v2).illumio.cloud.k8sclustersync.v1.EndpointH\x01R\x13destinationEndpoint\x88\x01\x01\x12Y\n" +
        "\x13destination_service\x18\n" +
        " \x01(\v2(.illumio.cloud.k8sclustersync.v1.ServiceR\x12destinationService\x12S\n" +
        "\x11egress_allowed_by\x18\v \x03(\v2'.illumio.cloud.k8sclustersync.v1.PolicyR\x0fegressAllowedBy\x12U\n" +
        "\x12ingress_allowed_by\x18\f \x03(\v2'.illumio.cloud.k8sclustersync.v1.PolicyR\x10ingressAllowedBy\x12Q\n" +
        "\x10egress_denied_by\x18\r \x03(\v2'.illumio.cloud.k8sclustersync.v1.PolicyR\x0eegressDeniedBy\x12S\n" +
        "\x11ingress_denied_by\x18\x0e \x03(\v2'.illumio.cloud.k8sclustersync.v1.PolicyR\x0fingressDeniedByB\x12\n" +
        "\x10_source_endpointB\x17\n" +
        "\x15_destination_endpoint\";\n" +
        "\aService\x12\x12\n" +
        "\x04name\x18\x01 \x01(\tR\x04name\x12\x1c\n" +
        "\tnamespace\x18\x02 \x01(\tR\tnamespace\"\x89\x01\n" +
        "\x02IP\x12\x16\n" +
        "\x06source\x18\x01 \x01(\tR\x06source\x12 \n" +
        "\vdestination\x18\x02 \x01(\tR\vdestination\x12I\n" +
        "\n" +
        "ip_version\x18\x03 \x01(\x0e2*.illumio.cloud.k8sclustersync.v1.IPVersionR\tipVersion\"\xcb\x02\n" +
        "\x06Layer4\x128\n" +
        "\x03tcp\x18\x01 \x01(\v2$.illumio.cloud.k8sclustersync.v1.TCPH\x00R\x03tcp\x128\n" +
        "\x03udp\x18\x02 \x01(\v2$.illumio.cloud.k8sclustersync.v1.UDPH\x00R\x03udp\x12A\n" +
        "\x06icmpv4\x18\x03 \x01(\v2'.illumio.cloud.k8sclustersync.v1.ICMPv4H\x00R\x06icmpv4\x12A\n" +
        "\x06icmpv6\x18\x04 \x01(\v2'.illumio.cloud.k8sclustersync.v1.ICMPv6H\x00R\x06icmpv6\x12;\n" +
        "\x04sctp\x18\x05 \x01(\v2%.illumio.cloud.k8sclustersync.v1.SCTPH\x00R\x04sctpB\n" +
        "\n" +
        "\bprotocol\"\x92\x01\n" +
        "\x03TCP\x12\x1f\n" +
        "\vsource_port\x18\x01 \x01(\rR\n" +
        "sourcePort\x12)\n" +
        "\x10destination_port\x18\x02 \x01(\rR\x0fdestinationPort\x12?\n" +
        "\x05flags\x18\x03 \x01(\v2).illumio.cloud.k8sclustersync.v1.TCPFlagsR\x05flags\"\xaa\x01\n" +
        "\bTCPFlags\x12\x10\n" +
        "\x03fin\x18\x01 \x01(\bR\x03fin\x12\x10\n" +
        "\x03syn\x18\x02 \x01(\bR\x03syn\x12\x10\n" +
        "\x03rst\x18\x03 \x01(\bR\x03rst\x12\x10\n" +
        "\x03psh\x18\x04 \x01(\bR\x03psh\x12\x10\n" +
        "\x03ack\x18\x05 \x01(\bR\x03ack\x12\x10\n" +
        "\x03urg\x18\x06 \x01(\bR\x03urg\x12\x10\n" +
        "\x03ece\x18\a \x01(\bR\x03ece\x12\x10\n" +
        "\x03cwr\x18\b \x01(\bR\x03cwr\x12\x0e\n" +
        "\x02ns\x18\t \x01(\bR\x02ns\"Q\n" +
        "\x03UDP\x12\x1f\n" +
        "\vsource_port\x18\x01 \x01(\rR\n" +
        "sourcePort\x12)\n" +
        "\x10destination_port\x18\x02 \x01(\rR\x0fdestinationPort\"R\n" +
        "\x04SCTP\x12\x1f\n" +
        "\vsource_port\x18\x01 \x01(\rR\n" +
        "sourcePort\x12)\n" +
        "\x10destination_port\x18\x02 \x01(\rR\x0fdestinationPort\"0\n" +
        "\x06ICMPv4\x12\x12\n" +
        "\x04type\x18\x01 \x01(\rR\x04type\x12\x12\n" +
        "\x04code\x18\x02 \x01(\rR\x04code\"0\n" +
        "\x06ICMPv6\x12\x12\n" +
        "\x04type\x18\x01 \x01(\rR\x04type\x12\x12\n" +
        "\x04code\x18\x02 \x01(\rR\x04code\"\xd9\x01\n" +
        "\bEndpoint\x12\x10\n" +
        "\x03uid\x18\x01 \x01(\rR\x03uid\x12!\n" +
        "\fcluster_name\x18\a \x01(\tR\vclusterName\x12\x1c\n" +
        "\tnamespace\x18\x03 \x01(\tR\tnamespace\x12\x16\n" +
        "\x06labels\x18\x04 \x03(\tR\x06labels\x12\x19\n" +
        "\bpod_name\x18\x05 \x01(\tR\apodName\x12G\n" +
        "\tworkloads\x18\x06 \x03(\v2).illumio.cloud.k8sclustersync.v1.WorkloadR\tworkloads\"2\n" +
        "\bWorkload\x12\x12\n" +
        "\x04name\x18\x01 \x01(\tR\x04name\x12\x12\n" +
        "\x04kind\x18\x02 \x01(\tR\x04kind\"n\n" +
        "\x06Policy\x12\x12\n" +
        "\x04name\x18\x01 \x01(\tR\x04name\x12\x1c\n" +
        "\tnamespace\x18\x02 \x01(\tR\tnamespace\x12\x16\n" +
        "\x06labels\x18\x03 \x03(\tR\x06labels\x12\x1a\n" +
        "\brevision\x18\x04 \x01(\x04R\brevision\"\x97\x02\n" +
        "!SendKubernetesNetworkFlowsRequest\x12J\n" +
        "\tkeepalive\x18\x03 \x01(\v2*.illumio.cloud.k8sclustersync.v1.KeepaliveH\x00R\tkeepalive\x12N\n" +
        "\vcilium_flow\x18\x01 \x01(\v2+.illumio.cloud.k8sclustersync.v1.CiliumFlowH\x00R\n" +
        "ciliumFlow\x12K\n" +
        "\n" +
        "falco_flow\x18\x02 \x01(\v2*.illumio.cloud.k8sclustersync.v1.FalcoFlowH\x00R\tfalcoFlowB\t\n" +
        "\arequest\"$\n" +
        "\"SendKubernetesNetworkFlowsResponse\"-\n" +
        "\bLogEntry\x12!\n" +
        "\fjson_message\x18\x03 \x01(\tR\vjsonMessage\"\xb2\x01\n" +
        "\x0fSendLogsRequest\x12J\n" +
        "\tkeepalive\x18\x02 \x01(\v2*.illumio.cloud.k8sclustersync.v1.KeepaliveH\x00R\tkeepalive\x12H\n" +
        "\tlog_entry\x18\x01 \x01(\v2).illumio.cloud.k8sclustersync.v1.LogEntryH\x00R\blogEntryB\t\n" +
        "\arequest\"N\n" +
        "\vSetLogLevel\x12?\n" +
        "\x05level\x18\x01 \x01(\x0e2).illumio.cloud.k8sclustersync.v1.LogLevelR\x05level\"r\n" +
        "\x10SendLogsResponse\x12R\n" +
        "\rset_log_level\x18\x01 \x01(\v2,.illumio.cloud.k8sclustersync.v1.SetLogLevelH\x00R\vsetLogLevelB\n" +
        "\n" +
        "\bresponse*\x81\x01\n" +
        "\rFlowCollector\x12\x1e\n" +
        "\x1aFLOW_COLLECTOR_UNSPECIFIED\x10\x00\x12\x1b\n" +
        "\x17FLOW_COLLECTOR_DISABLED\x10\x01\x12\x19\n" +
        "\x15FLOW_COLLECTOR_CILIUM\x10\x02\x12\x18\n" +
        "\x14FLOW_COLLECTOR_FALCO\x10\x03*\x8c\x01\n" +
        "\x10TrafficDirection\x12;\n" +
        "7TRAFFIC_DIRECTION_TRAFFIC_DIRECTION_UNKNOWN_UNSPECIFIED\x10\x00\x12\x1d\n" +
        "\x19TRAFFIC_DIRECTION_INGRESS\x10\x01\x12\x1c\n" +
        "\x18TRAFFIC_DIRECTION_EGRESS\x10\x02*\xc0\x01\n" +
        "\aVerdict\x12\x1f\n" +
        "\x1bVERDICT_UNKNOWN_UNSPECIFIED\x10\x00\x12\x15\n" +
        "\x11VERDICT_FORWARDED\x10\x01\x12\x13\n" +
        "\x0fVERDICT_DROPPED\x10\x02\x12\x11\n" +
        "\rVERDICT_ERROR\x10\x03\x12\x11\n" +
        "\rVERDICT_AUDIT\x10\x04\x12\x16\n" +
        "\x12VERDICT_REDIRECTED\x10\x05\x12\x12\n" +
        "\x0eVERDICT_TRACED\x10\x06\x12\x16\n" +
        "\x12VERDICT_TRANSLATED\x10\a*]\n" +
        "\tIPVersion\x12&amp;\n" +
        "\"IP_VERSION_IP_NOT_USED_UNSPECIFIED\x10\x00\x12\x13\n" +
        "\x0fIP_VERSION_IPV4\x10\x01\x12\x13\n" +
        "\x0fIP_VERSION_IPV6\x10\x02*w\n" +
        "\bLogLevel\x12\x19\n" +
        "\x15LOG_LEVEL_UNSPECIFIED\x10\x00\x12\x13\n" +
        "\x0fLOG_LEVEL_DEBUG\x10\x01\x12\x12\n" +
        "\x0eLOG_LEVEL_INFO\x10\x02\x12\x12\n" +
        "\x0eLOG_LEVEL_WARN\x10\x03\x12\x13\n" +
        "\x0fLOG_LEVEL_ERROR\x10\x042\xdb\x03\n" +
        "\x15KubernetesInfoService\x12\xa0\x01\n" +
        "\x17SendKubernetesResources\x12?.illumio.cloud.k8sclustersync.v1.SendKubernetesResourcesRequest\x1a@.illumio.cloud.k8sclustersync.v1.SendKubernetesResourcesResponse(\x010\x01\x12\xa9\x01\n" +
        "\x1aSendKubernetesNetworkFlows\x12B.illumio.cloud.k8sclustersync.v1.SendKubernetesNetworkFlowsRequest\x1aC.illumio.cloud.k8sclustersync.v1.SendKubernetesNetworkFlowsResponse(\x010\x01\x12s\n" +
        "\bSendLogs\x120.illumio.cloud.k8sclustersync.v1.SendLogsRequest\x1a1.illumio.cloud.k8sclustersync.v1.SendLogsResponse(\x010\x01B\xac\x02\n" +
        "#com.illumio.cloud.k8sclustersync.v1B\fK8sInfoProtoP\x01ZXgithub.com/illumio/cloudsecure-operator/illumio/cloud/k8sclustersync/v1;k8sclustersyncv1\xa2\x02\x03ICK\xaa\x02\x1fIllumio.Cloud.K8sclustersync.V1\xca\x02\x1fIllumio\\Cloud\\K8sclustersync\\V1\xe2\x02+Illumio\\Cloud\\K8sclustersync\\V1\\GPBMetadata\xea\x02\"Illumio::Cloud::K8sclustersync::V1b\x06proto3"

var (
        file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescOnce sync.Once
        file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescData []byte
)

func file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDesc), len(file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDescData</span>
}

var file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes = make([]protoimpl.MessageInfo, 34)
var file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_goTypes = []any{
        (FlowCollector)(0),                         // 0: illumio.cloud.k8sclustersync.v1.FlowCollector
        (TrafficDirection)(0),                      // 1: illumio.cloud.k8sclustersync.v1.TrafficDirection
        (Verdict)(0),                               // 2: illumio.cloud.k8sclustersync.v1.Verdict
        (IPVersion)(0),                             // 3: illumio.cloud.k8sclustersync.v1.IPVersion
        (LogLevel)(0),                              // 4: illumio.cloud.k8sclustersync.v1.LogLevel
        (*Keepalive)(nil),                          // 5: illumio.cloud.k8sclustersync.v1.Keepalive
        (*KubernetesObjectData)(nil),               // 6: illumio.cloud.k8sclustersync.v1.KubernetesObjectData
        (*KubernetesServiceData)(nil),              // 7: illumio.cloud.k8sclustersync.v1.KubernetesServiceData
        (*KubernetesNodeData)(nil),                 // 8: illumio.cloud.k8sclustersync.v1.KubernetesNodeData
        (*KubernetesPodData)(nil),                  // 9: illumio.cloud.k8sclustersync.v1.KubernetesPodData
        (*KubernetesOwnerReference)(nil),           // 10: illumio.cloud.k8sclustersync.v1.KubernetesOwnerReference
        (*KubernetesClusterMetadata)(nil),          // 11: illumio.cloud.k8sclustersync.v1.KubernetesClusterMetadata
        (*SendKubernetesResourcesRequest)(nil),     // 12: illumio.cloud.k8sclustersync.v1.SendKubernetesResourcesRequest
        (*KubernetesResourceSnapshotComplete)(nil), // 13: illumio.cloud.k8sclustersync.v1.KubernetesResourceSnapshotComplete
        (*SendKubernetesResourcesResponse)(nil),    // 14: illumio.cloud.k8sclustersync.v1.SendKubernetesResourcesResponse
        (*KubernetesResourceMutation)(nil),         // 15: illumio.cloud.k8sclustersync.v1.KubernetesResourceMutation
        (*FalcoFlow)(nil),                          // 16: illumio.cloud.k8sclustersync.v1.FalcoFlow
        (*CiliumFlow)(nil),                         // 17: illumio.cloud.k8sclustersync.v1.CiliumFlow
        (*Service)(nil),                            // 18: illumio.cloud.k8sclustersync.v1.Service
        (*IP)(nil),                                 // 19: illumio.cloud.k8sclustersync.v1.IP
        (*Layer4)(nil),                             // 20: illumio.cloud.k8sclustersync.v1.Layer4
        (*TCP)(nil),                                // 21: illumio.cloud.k8sclustersync.v1.TCP
        (*TCPFlags)(nil),                           // 22: illumio.cloud.k8sclustersync.v1.TCPFlags
        (*UDP)(nil),                                // 23: illumio.cloud.k8sclustersync.v1.UDP
        (*SCTP)(nil),                               // 24: illumio.cloud.k8sclustersync.v1.SCTP
        (*ICMPv4)(nil),                             // 25: illumio.cloud.k8sclustersync.v1.ICMPv4
        (*ICMPv6)(nil),                             // 26: illumio.cloud.k8sclustersync.v1.ICMPv6
        (*Endpoint)(nil),                           // 27: illumio.cloud.k8sclustersync.v1.Endpoint
        (*Workload)(nil),                           // 28: illumio.cloud.k8sclustersync.v1.Workload
        (*Policy)(nil),                             // 29: illumio.cloud.k8sclustersync.v1.Policy
        (*SendKubernetesNetworkFlowsRequest)(nil),  // 30: illumio.cloud.k8sclustersync.v1.SendKubernetesNetworkFlowsRequest
        (*SendKubernetesNetworkFlowsResponse)(nil), // 31: illumio.cloud.k8sclustersync.v1.SendKubernetesNetworkFlowsResponse
        (*LogEntry)(nil),                           // 32: illumio.cloud.k8sclustersync.v1.LogEntry
        (*SendLogsRequest)(nil),                    // 33: illumio.cloud.k8sclustersync.v1.SendLogsRequest
        (*SetLogLevel)(nil),                        // 34: illumio.cloud.k8sclustersync.v1.SetLogLevel
        (*SendLogsResponse)(nil),                   // 35: illumio.cloud.k8sclustersync.v1.SendLogsResponse
        nil,                                        // 36: illumio.cloud.k8sclustersync.v1.KubernetesObjectData.AnnotationsEntry
        nil,                                        // 37: illumio.cloud.k8sclustersync.v1.KubernetesObjectData.LabelsEntry
        (*KubernetesServiceData_ServicePort)(nil),  // 38: illumio.cloud.k8sclustersync.v1.KubernetesServiceData.ServicePort
        (*timestamppb.Timestamp)(nil),              // 39: google.protobuf.Timestamp
        (*wrapperspb.BoolValue)(nil),               // 40: google.protobuf.BoolValue
}
var file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_depIdxs = []int32{
        36, // 0: illumio.cloud.k8sclustersync.v1.KubernetesObjectData.annotations:type_name -&gt; illumio.cloud.k8sclustersync.v1.KubernetesObjectData.AnnotationsEntry
        39, // 1: illumio.cloud.k8sclustersync.v1.KubernetesObjectData.creation_timestamp:type_name -&gt; google.protobuf.Timestamp
        37, // 2: illumio.cloud.k8sclustersync.v1.KubernetesObjectData.labels:type_name -&gt; illumio.cloud.k8sclustersync.v1.KubernetesObjectData.LabelsEntry
        10, // 3: illumio.cloud.k8sclustersync.v1.KubernetesObjectData.owner_references:type_name -&gt; illumio.cloud.k8sclustersync.v1.KubernetesOwnerReference
        9,  // 4: illumio.cloud.k8sclustersync.v1.KubernetesObjectData.pod:type_name -&gt; illumio.cloud.k8sclustersync.v1.KubernetesPodData
        8,  // 5: illumio.cloud.k8sclustersync.v1.KubernetesObjectData.node:type_name -&gt; illumio.cloud.k8sclustersync.v1.KubernetesNodeData
        7,  // 6: illumio.cloud.k8sclustersync.v1.KubernetesObjectData.service:type_name -&gt; illumio.cloud.k8sclustersync.v1.KubernetesServiceData
        38, // 7: illumio.cloud.k8sclustersync.v1.KubernetesServiceData.ports:type_name -&gt; illumio.cloud.k8sclustersync.v1.KubernetesServiceData.ServicePort
        0,  // 8: illumio.cloud.k8sclustersync.v1.KubernetesClusterMetadata.flow_collector:type_name -&gt; illumio.cloud.k8sclustersync.v1.FlowCollector
        5,  // 9: illumio.cloud.k8sclustersync.v1.SendKubernetesResourcesRequest.keepalive:type_name -&gt; illumio.cloud.k8sclustersync.v1.Keepalive
        11, // 10: illumio.cloud.k8sclustersync.v1.SendKubernetesResourcesRequest.cluster_metadata:type_name -&gt; illumio.cloud.k8sclustersync.v1.KubernetesClusterMetadata
        6,  // 11: illumio.cloud.k8sclustersync.v1.SendKubernetesResourcesRequest.resource_data:type_name -&gt; illumio.cloud.k8sclustersync.v1.KubernetesObjectData
        13, // 12: illumio.cloud.k8sclustersync.v1.SendKubernetesResourcesRequest.resource_snapshot_complete:type_name -&gt; illumio.cloud.k8sclustersync.v1.KubernetesResourceSnapshotComplete
        15, // 13: illumio.cloud.k8sclustersync.v1.SendKubernetesResourcesRequest.kubernetes_resource_mutation:type_name -&gt; illumio.cloud.k8sclustersync.v1.KubernetesResourceMutation
        6,  // 14: illumio.cloud.k8sclustersync.v1.KubernetesResourceMutation.create_resource:type_name -&gt; illumio.cloud.k8sclustersync.v1.KubernetesObjectData
        6,  // 15: illumio.cloud.k8sclustersync.v1.KubernetesResourceMutation.update_resource:type_name -&gt; illumio.cloud.k8sclustersync.v1.KubernetesObjectData
        6,  // 16: illumio.cloud.k8sclustersync.v1.KubernetesResourceMutation.delete_resource:type_name -&gt; illumio.cloud.k8sclustersync.v1.KubernetesObjectData
        19, // 17: illumio.cloud.k8sclustersync.v1.FalcoFlow.layer3:type_name -&gt; illumio.cloud.k8sclustersync.v1.IP
        20, // 18: illumio.cloud.k8sclustersync.v1.FalcoFlow.layer4:type_name -&gt; illumio.cloud.k8sclustersync.v1.Layer4
        39, // 19: illumio.cloud.k8sclustersync.v1.FalcoFlow.timestamp:type_name -&gt; google.protobuf.Timestamp
        39, // 20: illumio.cloud.k8sclustersync.v1.CiliumFlow.time:type_name -&gt; google.protobuf.Timestamp
        1,  // 21: illumio.cloud.k8sclustersync.v1.CiliumFlow.traffic_direction:type_name -&gt; illumio.cloud.k8sclustersync.v1.TrafficDirection
        2,  // 22: illumio.cloud.k8sclustersync.v1.CiliumFlow.verdict:type_name -&gt; illumio.cloud.k8sclustersync.v1.Verdict
        19, // 23: illumio.cloud.k8sclustersync.v1.CiliumFlow.layer3:type_name -&gt; illumio.cloud.k8sclustersync.v1.IP
        20, // 24: illumio.cloud.k8sclustersync.v1.CiliumFlow.layer4:type_name -&gt; illumio.cloud.k8sclustersync.v1.Layer4
        40, // 25: illumio.cloud.k8sclustersync.v1.CiliumFlow.is_reply:type_name -&gt; google.protobuf.BoolValue
        27, // 26: illumio.cloud.k8sclustersync.v1.CiliumFlow.source_endpoint:type_name -&gt; illumio.cloud.k8sclustersync.v1.Endpoint
        27, // 27: illumio.cloud.k8sclustersync.v1.CiliumFlow.destination_endpoint:type_name -&gt; illumio.cloud.k8sclustersync.v1.Endpoint
        18, // 28: illumio.cloud.k8sclustersync.v1.CiliumFlow.destination_service:type_name -&gt; illumio.cloud.k8sclustersync.v1.Service
        29, // 29: illumio.cloud.k8sclustersync.v1.CiliumFlow.egress_allowed_by:type_name -&gt; illumio.cloud.k8sclustersync.v1.Policy
        29, // 30: illumio.cloud.k8sclustersync.v1.CiliumFlow.ingress_allowed_by:type_name -&gt; illumio.cloud.k8sclustersync.v1.Policy
        29, // 31: illumio.cloud.k8sclustersync.v1.CiliumFlow.egress_denied_by:type_name -&gt; illumio.cloud.k8sclustersync.v1.Policy
        29, // 32: illumio.cloud.k8sclustersync.v1.CiliumFlow.ingress_denied_by:type_name -&gt; illumio.cloud.k8sclustersync.v1.Policy
        3,  // 33: illumio.cloud.k8sclustersync.v1.IP.ip_version:type_name -&gt; illumio.cloud.k8sclustersync.v1.IPVersion
        21, // 34: illumio.cloud.k8sclustersync.v1.Layer4.tcp:type_name -&gt; illumio.cloud.k8sclustersync.v1.TCP
        23, // 35: illumio.cloud.k8sclustersync.v1.Layer4.udp:type_name -&gt; illumio.cloud.k8sclustersync.v1.UDP
        25, // 36: illumio.cloud.k8sclustersync.v1.Layer4.icmpv4:type_name -&gt; illumio.cloud.k8sclustersync.v1.ICMPv4
        26, // 37: illumio.cloud.k8sclustersync.v1.Layer4.icmpv6:type_name -&gt; illumio.cloud.k8sclustersync.v1.ICMPv6
        24, // 38: illumio.cloud.k8sclustersync.v1.Layer4.sctp:type_name -&gt; illumio.cloud.k8sclustersync.v1.SCTP
        22, // 39: illumio.cloud.k8sclustersync.v1.TCP.flags:type_name -&gt; illumio.cloud.k8sclustersync.v1.TCPFlags
        28, // 40: illumio.cloud.k8sclustersync.v1.Endpoint.workloads:type_name -&gt; illumio.cloud.k8sclustersync.v1.Workload
        5,  // 41: illumio.cloud.k8sclustersync.v1.SendKubernetesNetworkFlowsRequest.keepalive:type_name -&gt; illumio.cloud.k8sclustersync.v1.Keepalive
        17, // 42: illumio.cloud.k8sclustersync.v1.SendKubernetesNetworkFlowsRequest.cilium_flow:type_name -&gt; illumio.cloud.k8sclustersync.v1.CiliumFlow
        16, // 43: illumio.cloud.k8sclustersync.v1.SendKubernetesNetworkFlowsRequest.falco_flow:type_name -&gt; illumio.cloud.k8sclustersync.v1.FalcoFlow
        5,  // 44: illumio.cloud.k8sclustersync.v1.SendLogsRequest.keepalive:type_name -&gt; illumio.cloud.k8sclustersync.v1.Keepalive
        32, // 45: illumio.cloud.k8sclustersync.v1.SendLogsRequest.log_entry:type_name -&gt; illumio.cloud.k8sclustersync.v1.LogEntry
        4,  // 46: illumio.cloud.k8sclustersync.v1.SetLogLevel.level:type_name -&gt; illumio.cloud.k8sclustersync.v1.LogLevel
        34, // 47: illumio.cloud.k8sclustersync.v1.SendLogsResponse.set_log_level:type_name -&gt; illumio.cloud.k8sclustersync.v1.SetLogLevel
        12, // 48: illumio.cloud.k8sclustersync.v1.KubernetesInfoService.SendKubernetesResources:input_type -&gt; illumio.cloud.k8sclustersync.v1.SendKubernetesResourcesRequest
        30, // 49: illumio.cloud.k8sclustersync.v1.KubernetesInfoService.SendKubernetesNetworkFlows:input_type -&gt; illumio.cloud.k8sclustersync.v1.SendKubernetesNetworkFlowsRequest
        33, // 50: illumio.cloud.k8sclustersync.v1.KubernetesInfoService.SendLogs:input_type -&gt; illumio.cloud.k8sclustersync.v1.SendLogsRequest
        14, // 51: illumio.cloud.k8sclustersync.v1.KubernetesInfoService.SendKubernetesResources:output_type -&gt; illumio.cloud.k8sclustersync.v1.SendKubernetesResourcesResponse
        31, // 52: illumio.cloud.k8sclustersync.v1.KubernetesInfoService.SendKubernetesNetworkFlows:output_type -&gt; illumio.cloud.k8sclustersync.v1.SendKubernetesNetworkFlowsResponse
        35, // 53: illumio.cloud.k8sclustersync.v1.KubernetesInfoService.SendLogs:output_type -&gt; illumio.cloud.k8sclustersync.v1.SendLogsResponse
        51, // [51:54] is the sub-list for method output_type
        48, // [48:51] is the sub-list for method input_type
        48, // [48:48] is the sub-list for extension type_name
        48, // [48:48] is the sub-list for extension extendee
        0,  // [0:48] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_init() }</span>
func file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_init() <span class="cov8" title="1">{
        if File_illumio_cloud_k8sclustersync_v1_k8s_info_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[1].OneofWrappers = []any{
                (*KubernetesObjectData_Pod)(nil),
                (*KubernetesObjectData_Node)(nil),
                (*KubernetesObjectData_Service)(nil),
        }
        file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[2].OneofWrappers = []any{}
        file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[7].OneofWrappers = []any{
                (*SendKubernetesResourcesRequest_Keepalive)(nil),
                (*SendKubernetesResourcesRequest_ClusterMetadata)(nil),
                (*SendKubernetesResourcesRequest_ResourceData)(nil),
                (*SendKubernetesResourcesRequest_ResourceSnapshotComplete)(nil),
                (*SendKubernetesResourcesRequest_KubernetesResourceMutation)(nil),
        }
        file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[10].OneofWrappers = []any{
                (*KubernetesResourceMutation_CreateResource)(nil),
                (*KubernetesResourceMutation_UpdateResource)(nil),
                (*KubernetesResourceMutation_DeleteResource)(nil),
        }
        file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[11].OneofWrappers = []any{
                (*FalcoFlow_Time)(nil),
                (*FalcoFlow_Timestamp)(nil),
        }
        file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[12].OneofWrappers = []any{}
        file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[15].OneofWrappers = []any{
                (*Layer4_Tcp)(nil),
                (*Layer4_Udp)(nil),
                (*Layer4_Icmpv4)(nil),
                (*Layer4_Icmpv6)(nil),
                (*Layer4_Sctp)(nil),
        }
        file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[25].OneofWrappers = []any{
                (*SendKubernetesNetworkFlowsRequest_Keepalive)(nil),
                (*SendKubernetesNetworkFlowsRequest_CiliumFlow)(nil),
                (*SendKubernetesNetworkFlowsRequest_FalcoFlow)(nil),
        }
        file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[28].OneofWrappers = []any{
                (*SendLogsRequest_Keepalive)(nil),
                (*SendLogsRequest_LogEntry)(nil),
        }
        file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[30].OneofWrappers = []any{
                (*SendLogsResponse_SetLogLevel)(nil),
        }
        file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes[33].OneofWrappers = []any{}
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDesc), len(file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_rawDesc)),
                        NumEnums:      5,
                        NumMessages:   34,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_goTypes,
                DependencyIndexes: file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_depIdxs,
                EnumInfos:         file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_enumTypes,
                MessageInfos:      file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_msgTypes,
        }.Build()
        File_illumio_cloud_k8sclustersync_v1_k8s_info_proto = out.File
        file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_goTypes = nil
        file_illumio_cloud_k8sclustersync_v1_k8s_info_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2024 Illumio, Inc. All Rights Reserved.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: illumio/cloud/k8sclustersync/v1/k8s_info.proto

package k8sclustersyncv1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
        KubernetesInfoService_SendKubernetesResources_FullMethodName    = "/illumio.cloud.k8sclustersync.v1.KubernetesInfoService/SendKubernetesResources"
        KubernetesInfoService_SendKubernetesNetworkFlows_FullMethodName = "/illumio.cloud.k8sclustersync.v1.KubernetesInfoService/SendKubernetesNetworkFlows"
        KubernetesInfoService_SendLogs_FullMethodName                   = "/illumio.cloud.k8sclustersync.v1.KubernetesInfoService/SendLogs"
)

// KubernetesInfoServiceClient is the client API for KubernetesInfoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KubernetesInfoServiceClient interface {
        // Continuously syncs the inventory of the Kubernetes resources in the cluster into CloudSecure.
        SendKubernetesResources(ctx context.Context, opts ...grpc.CallOption) (KubernetesInfoService_SendKubernetesResourcesClient, error)
        // Continuously sends network flows exported by the CNI plugin in the cluster to CloudSecure.
        SendKubernetesNetworkFlows(ctx context.Context, opts ...grpc.CallOption) (KubernetesInfoService_SendKubernetesNetworkFlowsClient, error)
        // Continuously syncs logs from operator and cluster.
        SendLogs(ctx context.Context, opts ...grpc.CallOption) (KubernetesInfoService_SendLogsClient, error)
}

type kubernetesInfoServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewKubernetesInfoServiceClient(cc grpc.ClientConnInterface) KubernetesInfoServiceClient <span class="cov0" title="0">{
        return &amp;kubernetesInfoServiceClient{cc}
}</span>

func (c *kubernetesInfoServiceClient) SendKubernetesResources(ctx context.Context, opts ...grpc.CallOption) (KubernetesInfoService_SendKubernetesResourcesClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;KubernetesInfoService_ServiceDesc.Streams[0], KubernetesInfoService_SendKubernetesResources_FullMethodName, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;kubernetesInfoServiceSendKubernetesResourcesClient{stream}
        return x, nil</span>
}

type KubernetesInfoService_SendKubernetesResourcesClient interface {
        Send(*SendKubernetesResourcesRequest) error
        Recv() (*SendKubernetesResourcesResponse, error)
        grpc.ClientStream
}

type kubernetesInfoServiceSendKubernetesResourcesClient struct {
        grpc.ClientStream
}

func (x *kubernetesInfoServiceSendKubernetesResourcesClient) Send(m *SendKubernetesResourcesRequest) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *kubernetesInfoServiceSendKubernetesResourcesClient) Recv() (*SendKubernetesResourcesResponse, error) <span class="cov0" title="0">{
        m := new(SendKubernetesResourcesResponse)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *kubernetesInfoServiceClient) SendKubernetesNetworkFlows(ctx context.Context, opts ...grpc.CallOption) (KubernetesInfoService_SendKubernetesNetworkFlowsClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;KubernetesInfoService_ServiceDesc.Streams[1], KubernetesInfoService_SendKubernetesNetworkFlows_FullMethodName, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;kubernetesInfoServiceSendKubernetesNetworkFlowsClient{stream}
        return x, nil</span>
}

type KubernetesInfoService_SendKubernetesNetworkFlowsClient interface {
        Send(*SendKubernetesNetworkFlowsRequest) error
        Recv() (*SendKubernetesNetworkFlowsResponse, error)
        grpc.ClientStream
}

type kubernetesInfoServiceSendKubernetesNetworkFlowsClient struct {
        grpc.ClientStream
}

func (x *kubernetesInfoServiceSendKubernetesNetworkFlowsClient) Send(m *SendKubernetesNetworkFlowsRequest) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *kubernetesInfoServiceSendKubernetesNetworkFlowsClient) Recv() (*SendKubernetesNetworkFlowsResponse, error) <span class="cov0" title="0">{
        m := new(SendKubernetesNetworkFlowsResponse)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *kubernetesInfoServiceClient) SendLogs(ctx context.Context, opts ...grpc.CallOption) (KubernetesInfoService_SendLogsClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;KubernetesInfoService_ServiceDesc.Streams[2], KubernetesInfoService_SendLogs_FullMethodName, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;kubernetesInfoServiceSendLogsClient{stream}
        return x, nil</span>
}

type KubernetesInfoService_SendLogsClient interface {
        Send(*SendLogsRequest) error
        Recv() (*SendLogsResponse, error)
        grpc.ClientStream
}

type kubernetesInfoServiceSendLogsClient struct {
        grpc.ClientStream
}

func (x *kubernetesInfoServiceSendLogsClient) Send(m *SendLogsRequest) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *kubernetesInfoServiceSendLogsClient) Recv() (*SendLogsResponse, error) <span class="cov0" title="0">{
        m := new(SendLogsResponse)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// KubernetesInfoServiceServer is the server API for KubernetesInfoService service.
// All implementations must embed UnimplementedKubernetesInfoServiceServer
// for forward compatibility
type KubernetesInfoServiceServer interface {
        // Continuously syncs the inventory of the Kubernetes resources in the cluster into CloudSecure.
        SendKubernetesResources(KubernetesInfoService_SendKubernetesResourcesServer) error
        // Continuously sends network flows exported by the CNI plugin in the cluster to CloudSecure.
        SendKubernetesNetworkFlows(KubernetesInfoService_SendKubernetesNetworkFlowsServer) error
        // Continuously syncs logs from operator and cluster.
        SendLogs(KubernetesInfoService_SendLogsServer) error
        mustEmbedUnimplementedKubernetesInfoServiceServer()
}

// UnimplementedKubernetesInfoServiceServer must be embedded to have forward compatible implementations.
type UnimplementedKubernetesInfoServiceServer struct {
}

func (UnimplementedKubernetesInfoServiceServer) SendKubernetesResources(KubernetesInfoService_SendKubernetesResourcesServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method SendKubernetesResources not implemented")
}</span>
func (UnimplementedKubernetesInfoServiceServer) SendKubernetesNetworkFlows(KubernetesInfoService_SendKubernetesNetworkFlowsServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method SendKubernetesNetworkFlows not implemented")
}</span>
func (UnimplementedKubernetesInfoServiceServer) SendLogs(KubernetesInfoService_SendLogsServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method SendLogs not implemented")
}</span>
func (UnimplementedKubernetesInfoServiceServer) mustEmbedUnimplementedKubernetesInfoServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeKubernetesInfoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KubernetesInfoServiceServer will
// result in compilation errors.
type UnsafeKubernetesInfoServiceServer interface {
        mustEmbedUnimplementedKubernetesInfoServiceServer()
}

func RegisterKubernetesInfoServiceServer(s grpc.ServiceRegistrar, srv KubernetesInfoServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;KubernetesInfoService_ServiceDesc, srv)
}</span>

func _KubernetesInfoService_SendKubernetesResources_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(KubernetesInfoServiceServer).SendKubernetesResources(&amp;kubernetesInfoServiceSendKubernetesResourcesServer{stream})
}</span>

type KubernetesInfoService_SendKubernetesResourcesServer interface {
        Send(*SendKubernetesResourcesResponse) error
        Recv() (*SendKubernetesResourcesRequest, error)
        grpc.ServerStream
}

type kubernetesInfoServiceSendKubernetesResourcesServer struct {
        grpc.ServerStream
}

func (x *kubernetesInfoServiceSendKubernetesResourcesServer) Send(m *SendKubernetesResourcesResponse) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *kubernetesInfoServiceSendKubernetesResourcesServer) Recv() (*SendKubernetesResourcesRequest, error) <span class="cov0" title="0">{
        m := new(SendKubernetesResourcesRequest)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func _KubernetesInfoService_SendKubernetesNetworkFlows_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(KubernetesInfoServiceServer).SendKubernetesNetworkFlows(&amp;kubernetesInfoServiceSendKubernetesNetworkFlowsServer{stream})
}</span>

type KubernetesInfoService_SendKubernetesNetworkFlowsServer interface {
        Send(*SendKubernetesNetworkFlowsResponse) error
        Recv() (*SendKubernetesNetworkFlowsRequest, error)
        grpc.ServerStream
}

type kubernetesInfoServiceSendKubernetesNetworkFlowsServer struct {
        grpc.ServerStream
}

func (x *kubernetesInfoServiceSendKubernetesNetworkFlowsServer) Send(m *SendKubernetesNetworkFlowsResponse) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *kubernetesInfoServiceSendKubernetesNetworkFlowsServer) Recv() (*SendKubernetesNetworkFlowsRequest, error) <span class="cov0" title="0">{
        m := new(SendKubernetesNetworkFlowsRequest)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func _KubernetesInfoService_SendLogs_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(KubernetesInfoServiceServer).SendLogs(&amp;kubernetesInfoServiceSendLogsServer{stream})
}</span>

type KubernetesInfoService_SendLogsServer interface {
        Send(*SendLogsResponse) error
        Recv() (*SendLogsRequest, error)
        grpc.ServerStream
}

type kubernetesInfoServiceSendLogsServer struct {
        grpc.ServerStream
}

func (x *kubernetesInfoServiceSendLogsServer) Send(m *SendLogsResponse) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *kubernetesInfoServiceSendLogsServer) Recv() (*SendLogsRequest, error) <span class="cov0" title="0">{
        m := new(SendLogsRequest)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// KubernetesInfoService_ServiceDesc is the grpc.ServiceDesc for KubernetesInfoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KubernetesInfoService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "illumio.cloud.k8sclustersync.v1.KubernetesInfoService",
        HandlerType: (*KubernetesInfoServiceServer)(nil),
        Methods:     []grpc.MethodDesc{},
        Streams: []grpc.StreamDesc{
                {
                        StreamName:    "SendKubernetesResources",
                        Handler:       _KubernetesInfoService_SendKubernetesResources_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
                {
                        StreamName:    "SendKubernetesNetworkFlows",
                        Handler:       _KubernetesInfoService_SendKubernetesNetworkFlows_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
                {
                        StreamName:    "SendLogs",
                        Handler:       _KubernetesInfoService_SendLogs_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
        },
        Metadata: "illumio/cloud/k8sclustersync/v1/k8s_info.proto",
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2024 Illumio, Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "context"
        "errors"
        "net/http"

        // Import all Kubernetes client auth plugins (e.g. Azure, GCP, OIDC, etc.)
        // to ensure that exec-entrypoint and run can make use of them.

        "github.com/google/gops/agent"
        "github.com/spf13/viper"
        "go.uber.org/zap"
        _ "k8s.io/client-go/plugin/pkg/client/auth"

        controller "github.com/illumio/cloud-operator/internal/controller"
        //+kubebuilder:scaffold:imports
)

const (
        defaultStreamKeepalivePeriodKubernetesResources    = "10s"
        defaultStreamKeepalivePeriodKubernetesNetworkFlows = "10s"
        defaultStreamKeepalivePeriodLogs                   = "10s"
)

// newHealthHandler returns an HTTP HandlerFunc that checks the health of the server by calling the given function and returns a status code accordingly
func newHealthHandler(checkFunc func() bool) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if checkFunc() </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                }</span> else<span class="cov0" title="0"> {
                        w.WriteHeader(http.StatusInternalServerError)
                }</span>
        }
}

// bindEnv is a helper function that binds an environment variable to a key and handles errors.
func bindEnv(logger *zap.Logger, key, envVar string) <span class="cov0" title="0">{
        if err := viper.BindEnv(key, envVar); err != nil </span><span class="cov0" title="0">{
                logger.Error("Error binding environment variable",
                        zap.Error(errors.New("error binding environment variable")),
                        zap.String("variable", envVar),
                )
        }</span>
}

func main() <span class="cov0" title="0">{
        // Create a buffered grpc write syncer without a valid gRPC connection initially
        // Using nil for the `pb.KubernetesInfoService_KubernetesLogsClient`.
        bufferedGrpcSyncer := controller.NewBufferedGrpcWriteSyncer()
        logger := controller.NewProductionGRPCLogger(bufferedGrpcSyncer)
        defer logger.Sync() //nolint:errcheck

        viper.AutomaticEnv()

        // Bind specific environment variables to keys
        bindEnv(logger, "cluster_creds", "CLUSTER_CREDS_SECRET")
        bindEnv(logger, "cilium_namespace", "CILIUM_NAMESPACE")
        bindEnv(logger, "onboarding_client_id", "ONBOARDING_CLIENT_ID")
        bindEnv(logger, "onboarding_client_secret", "ONBOARDING_CLIENT_SECRET")
        bindEnv(logger, "onboarding_endpoint", "ONBOARDING_ENDPOINT")
        bindEnv(logger, "token_endpoint", "TOKEN_ENDPOINT")
        bindEnv(logger, "tls_skip_verify", "TLS_SKIP_VERIFY")
        bindEnv(logger, "stream_keepalive_period_kubernetes_resources", "STREAM_KEEPALIVE_PERIOD_KUBERNETES_RESOURCES")
        bindEnv(logger, "stream_keepalive_period_kubernetes_network_flows", "STREAM_KEEPALIVE_PERIOD_KUBERNETES_NETWORK_FLOWS")
        bindEnv(logger, "stream_keepalive_period_logs", "STREAM_KEEPALIVE_PERIOD_LOGS")

        // Set default values
        viper.SetDefault("cluster_creds", "clustercreds")
        viper.SetDefault("cilium_namespace", "kube-system")
        viper.SetDefault("onboarding_endpoint", "https://dev.cloud.ilabs.io/api/v1/k8s_cluster/onboard")
        viper.SetDefault("token_endpoint", "https://dev.cloud.ilabs.io/api/v1/k8s_cluster/authenticate")
        viper.SetDefault("tls_skip_verify", false)
        viper.SetDefault("stream_keepalive_period_kubernetes_resources", defaultStreamKeepalivePeriodKubernetesResources)
        viper.SetDefault("stream_keepalive_period_kubernetes_network_flows", defaultStreamKeepalivePeriodKubernetesNetworkFlows)
        viper.SetDefault("stream_keepalive_period_logs", defaultStreamKeepalivePeriodLogs)

        envConfig := controller.EnvironmentConfig{
                ClusterCreds:           viper.GetString("cluster_creds"),
                CiliumNamespace:        viper.GetString("cilium_namespace"),
                OnboardingClientId:     viper.GetString("onboarding_client_id"),
                OnboardingClientSecret: viper.GetString("onboarding_client_secret"),
                OnboardingEndpoint:     viper.GetString("onboarding_endpoint"),
                TokenEndpoint:          viper.GetString("token_endpoint"),
                TlsSkipVerify:          viper.GetBool("tls_skip_verify"),
                KeepalivePeriods: controller.KeepalivePeriods{
                        KubernetesResources:    viper.GetDuration("stream_keepalive_period_kubernetes_resources"),
                        KubernetesNetworkFlows: viper.GetDuration("stream_keepalive_period_kubernetes_network_flows"),
                        Logs:                   viper.GetDuration("stream_keepalive_period_logs"),
                },
        }

        logger.Info("Starting application",
                zap.String("cluster_creds_secret", envConfig.ClusterCreds),
                zap.String("cilium_namespace", envConfig.CiliumNamespace),
                zap.String("onboarding_client_id", envConfig.OnboardingClientId),
                zap.String("onboarding_endpoint", envConfig.OnboardingEndpoint),
                zap.String("token_endpoint", envConfig.TokenEndpoint),
                zap.Bool("tls_skip_verify", envConfig.TlsSkipVerify),
                zap.Duration("stream_keepalive_period_kubernetes_resources", envConfig.KeepalivePeriods.KubernetesResources),
                zap.Duration("stream_keepalive_period_kubernetes_network_flows", envConfig.KeepalivePeriods.KubernetesNetworkFlows),
                zap.Duration("stream_keepalive_period_logs", envConfig.KeepalivePeriods.Logs),
        )

        // Start the gops agent and listen on a specific address and port
        if err := agent.Listen(agent.Options{}); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to start gops agent", zap.Error(err))
        }</span>
        <span class="cov0" title="0">http.HandleFunc("/healthz", newHealthHandler(controller.ServerIsHealthy))
        healthChecker := &amp;http.Server{Addr: ":8080"}

        errChan := make(chan error, 1)

        go func() </span><span class="cov0" title="0">{
                errChan &lt;- healthChecker.ListenAndServe()
                err := &lt;-errChan
                logger.Fatal("healthz check server failed", zap.Error(err))
        }</span>()

        <span class="cov0" title="0">ctx := context.Background()
        controller.ConnectStreams(ctx, logger, envConfig, bufferedGrpcSyncer)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2024 Illumio, Inc. All Rights Reserved.

package controller

import (
        "context"
        "crypto/tls"
        "errors"
        "net/http"
        "os"
        "path/filepath"
        "time"

        "github.com/golang-jwt/jwt/v4"
        "go.uber.org/zap"
        "golang.org/x/oauth2"
        "golang.org/x/oauth2/clientcredentials"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/util/homedir"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/credentials/oauth"
        "google.golang.org/grpc/keepalive"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var kacp = keepalive.ClientParameters{
        Time:                10 * time.Second, // send pings every 10 seconds if there is no activity
        Timeout:             10 * time.Second, // wait 10s for ping ack before considering the connection dead
        PermitWithoutStream: true,             // send pings even without active streams
}

// Authenticator keeps a logger for its own methods.
type Authenticator struct {
        Logger *zap.Logger
}

// GetOnboardingCredentials returns credentials to onboard this cluster with CloudSecure.
func (authn *Authenticator) GetOnboardingCredentials(ctx context.Context, clientID string, clientSecret string) (Credentials, error) <span class="cov0" title="0">{
        if clientID == "" || clientSecret == "" </span><span class="cov0" title="0">{
                return Credentials{}, errors.New("incomplete credentials found")
        }</span>
        <span class="cov0" title="0">return Credentials{ClientID: clientID, ClientSecret: clientSecret}, nil</span>
}

// ReadK8sSecret takes a secretName and reads the file.
func (authn *Authenticator) ReadCredentialsK8sSecrets(ctx context.Context, secretName string) (string, string, error) <span class="cov0" title="0">{
        // Create a new clientset
        clientset, err := NewClientSet()
        if err != nil </span><span class="cov0" title="0">{
                authn.Logger.Error("Failed to create clientSet", zap.Error(err))
                return "", "", err
        }</span>

        // Get the secret
        <span class="cov0" title="0">secret, err := clientset.CoreV1().Secrets("illumio-cloud").Get(ctx, secretName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                authn.Logger.Error("Failed to get secret", zap.Error(err))
                return "", "", err
        }</span>

        // Assuming your secret data has a "client_id" and "client_secret" key.
        <span class="cov0" title="0">clientID := string(secret.Data[string(ONBOARDING_CLIENT_ID)])
        if clientID == "" </span><span class="cov0" title="0">{
                return "", "", NewCredentialNotFoundInK8sSecretError(ONBOARDING_CLIENT_ID)
        }</span>
        <span class="cov0" title="0">clientSecret := string(secret.Data[string(ONBOARDING_CLIENT_SECRET)])
        if clientSecret == "" </span><span class="cov0" title="0">{
                return "", "", NewCredentialNotFoundInK8sSecretError(ONBOARDING_CLIENT_SECRET)
        }</span>
        <span class="cov0" title="0">return clientID, clientSecret, nil</span>
}

func (authn *Authenticator) DoesK8sSecretExist(ctx context.Context, secretName string) bool <span class="cov0" title="0">{
        clientset, err := NewClientSet()
        if err != nil </span><span class="cov0" title="0">{
                authn.Logger.Error("Failed to create clientSet", zap.Error(err))
        }</span>

        // Get the secret -&gt; illumio-cloud will need to be configurable
        <span class="cov0" title="0">_, err = clientset.CoreV1().Secrets("illumio-cloud").Get(ctx, secretName, metav1.GetOptions{})
        return err == nil</span>
}

// WriteK8sSecret takes an OnboardResponse and writes it to a locally kept secret.
func (authn *Authenticator) WriteK8sSecret(ctx context.Context, keyData OnboardResponse, ClusterCreds string) error <span class="cov0" title="0">{
        clientset, err := NewClientSet()
        if err != nil </span><span class="cov0" title="0">{
                authn.Logger.Error("Failed to create clientSet", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">secretData := map[string][]byte{
                string(ONBOARDING_CLIENT_ID):     []byte(keyData.ClusterClientId),
                string(ONBOARDING_CLIENT_SECRET): []byte(keyData.ClusterClientSecret),
        }
        namespace := "illumio-cloud" // Will be made configurable.
        secret := &amp;corev1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      ClusterCreds,
                        Namespace: namespace,
                },
                Data: secretData,
        }

        _, err = clientset.CoreV1().Secrets(namespace).Update(ctx, secret, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                authn.Logger.Error("Failed to update secret", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// NewClientSet returns a new Kubernetes clientset based on the execution environment.
func NewClientSet() (*kubernetes.Clientset, error) <span class="cov0" title="0">{
        var clusterConfig *rest.Config
        var err error

        if os.Getenv("KUBECONFIG") != "" || !IsRunningInCluster() </span><span class="cov0" title="0">{
                var kubeconfig string
                if home := homedir.HomeDir(); home != "" </span><span class="cov0" title="0">{
                        kubeconfig = filepath.Join(home, ".kube", "config")
                }</span>
                <span class="cov0" title="0">clusterConfig, err = clientcmd.BuildConfigFromFlags("", kubeconfig)</span>
        } else<span class="cov0" title="0"> {
                clusterConfig, err = rest.InClusterConfig()
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return kubernetes.NewForConfig(clusterConfig)</span>
}

// IsRunningInCluster helps determine if the application is running inside a Kubernetes cluster.
func IsRunningInCluster() bool <span class="cov8" title="1">{
        // This can be based on the existence of a service account token, environment variables, or similar.
        return os.Getenv("KUBERNETES_SERVICE_HOST") != ""
}</span>

// SetUpOAuthConnection establishes a gRPC connection using OAuth credentials and logging the process.
func SetUpOAuthConnection(
        ctx context.Context,
        logger *zap.Logger,
        tokenURL string,
        tlsSkipVerify bool,
        clientID string,
        clientSecret string,
) (*grpc.ClientConn, error) <span class="cov0" title="0">{
        tlsConfig := GetTLSConfig(tlsSkipVerify)
        contextWithTimeout, cancel := context.WithTimeout(ctx, time.Second*10)
        defer cancel()
        oauthConfig := clientcredentials.Config{
                ClientID:     clientID,
                ClientSecret: clientSecret,
                TokenURL:     tokenURL,
                AuthStyle:    oauth2.AuthStyleInParams,
        }
        tokenSource := GetTokenSource(contextWithTimeout, oauthConfig, tlsConfig)

        token, err := tokenSource.Token()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error retrieving a valid token", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">claims, err := ParseToken(token.AccessToken)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error parsing token", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">aud, err := getFirstAudience(logger, claims)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error pulling audience out of token", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">tokenSource = GetTokenSource(ctx, oauthConfig, tlsConfig)
        creds := credentials.NewTLS(tlsConfig)
        conn, err := grpc.NewClient(
                aud,
                grpc.WithTransportCredentials(creds),
                grpc.WithPerRPCCredentials(oauth.TokenSource{TokenSource: tokenSource}),
                grpc.WithKeepaliveParams(kacp),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return conn, nil</span>
}

// GetTLSConfig returns a TLS configuration.
func GetTLSConfig(skipVerify bool) *tls.Config <span class="cov0" title="0">{
        return &amp;tls.Config{
                MinVersion:         tls.VersionTLS12,
                InsecureSkipVerify: skipVerify,
        }
}</span>

// GetTokenSource returns an OAuth2 token source.
func GetTokenSource(ctx context.Context, config clientcredentials.Config, tlsConfig *tls.Config) oauth2.TokenSource <span class="cov0" title="0">{
        return config.TokenSource(context.WithValue(ctx, oauth2.HTTPClient, &amp;http.Client{
                Transport: &amp;http.Transport{
                        TLSClientConfig: tlsConfig,
                },
        }))
}</span>

// ParseToken parses the JWT token and returns the claims.
func ParseToken(tokenString string) (jwt.MapClaims, error) <span class="cov0" title="0">{
        claims := jwt.MapClaims{}
        _, _, err := jwt.NewParser().ParseUnverified(tokenString, claims)
        return claims, err
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package controller

import "fmt"

type credentialNotFoundInK8sSecretError struct {
        RequiredFieldName onboardingCredentialRequiredField
}

type onboardingCredentialRequiredField string

// Credentials contains attributes that are needed for onboarding.
type Credentials struct {
        ClientID     string `json:"client_id"`
        ClientSecret string `json:"client_secret"`
}

const (
        ONBOARDING_CLIENT_ID     = onboardingCredentialRequiredField("client_id")
        ONBOARDING_CLIENT_SECRET = onboardingCredentialRequiredField("client_secret")
)

var (
        // In the onboarding flow, an administrator gives cloud-operator credentials
        // via helm's value.yaml mechanism. For the sake of operability,
        // cloud-operator then persists these credentials into a k8s secret, so
        // subsequent installs on the same cluster do not require the administrator to
        // repeat the credentials every time. There are multiple specific fields in
        // this secret
        //
        // This error type indicates that at least one of the required fields is
        // missing from the secret.
        ErrCredentialNotFoundInK8sSecret error = &amp;credentialNotFoundInK8sSecretError{}
)

func NewCredentialNotFoundInK8sSecretError(requiredField onboardingCredentialRequiredField) error <span class="cov0" title="0">{
        return &amp;credentialNotFoundInK8sSecretError{
                RequiredFieldName: requiredField,
        }
}</span>

func (e *credentialNotFoundInK8sSecretError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Required field not found in k8s Secret | field='%s'", e.RequiredFieldName)
}</span>

func (e *credentialNotFoundInK8sSecretError) Is(target error) bool <span class="cov0" title="0">{
        return target == ErrCredentialNotFoundInK8sSecret
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2024 Illumio, Inc. All Rights Reserved.

package controller

import (
        "context"
        "errors"
        "fmt"

        "github.com/cilium/cilium/api/v1/flow"
        observer "github.com/cilium/cilium/api/v1/observer"
        pb "github.com/illumio/cloud-operator/api/illumio/cloud/k8sclustersync/v1"
        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
)

// CiliumFlowCollector collects flows from Cilium Hubble Relay running in this cluster.
type CiliumFlowCollector struct {
        logger *zap.Logger
        client observer.ObserverClient
}

const (
        ciliumHubbleRelayMaxFlowCount uint64 = 100
        ciliumHubbleRelayServiceName  string = "hubble-relay"
)

var (
        ErrHubbleNotFound   = errors.New("hubble Relay service not found; disabling Cilium flow collection")
        ErrNoPortsAvailable = errors.New("hubble Relay service has no ports; disabling Cilium flow collection")
)

// discoverCiliumHubbleRelayAddress uses a kubernetes clientset in order to discover the address of the hubble-relay service within kube-system.
func discoverCiliumHubbleRelayAddress(ctx context.Context, ciliumNamespace string, clientset kubernetes.Interface) (string, error) <span class="cov0" title="0">{
        service, err := clientset.CoreV1().Services(ciliumNamespace).Get(ctx, ciliumHubbleRelayServiceName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrHubbleNotFound
        }</span>

        <span class="cov0" title="0">if len(service.Spec.Ports) == 0 </span><span class="cov0" title="0">{
                return "", ErrNoPortsAvailable
        }</span>

        <span class="cov0" title="0">address := fmt.Sprintf("%s:%d", service.Spec.ClusterIP, service.Spec.Ports[0].Port)
        return address, nil</span>
}

// newCiliumCollector connects to Ciilium Hubble Relay, sets up an Observer client, and returns a new Collector using it.
func newCiliumFlowCollector(ctx context.Context, logger *zap.Logger, ciliumNamespace string) (*CiliumFlowCollector, error) <span class="cov0" title="0">{
        config, err := NewClientSet()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create new client set: %w", err)
        }</span>
        <span class="cov0" title="0">hubbleAddress, err := discoverCiliumHubbleRelayAddress(ctx, ciliumNamespace, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">conn, err := grpc.NewClient(hubbleAddress, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to Cilium Hubble Relay: %w", err)
        }</span>
        <span class="cov0" title="0">hubbleClient := observer.NewObserverClient(conn)
        return &amp;CiliumFlowCollector{logger: logger, client: hubbleClient}, nil</span>
}

// convertCiliumIP converts a flow.IP object to a pb.IP object
func convertCiliumIP(IP *flow.IP) *pb.IP <span class="cov0" title="0">{
        if IP == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;pb.IP{
                Source:      IP.GetSource(),
                Destination: IP.GetDestination(),
                IpVersion:   pb.IPVersion(IP.GetIpVersion()),
        }</span>
}

// convertCiliumLayer4 function converts a slice of flow.Layer4 objects to a slice of pb.Layer4 objects.
func convertCiliumLayer4(l4 *flow.Layer4) *pb.Layer4 <span class="cov0" title="0">{
        if l4 == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">layer4 := &amp;pb.Layer4{}
        switch protocol := l4.Protocol.(type) </span>{
        case *flow.Layer4_TCP:<span class="cov0" title="0">
                layer4.Protocol = &amp;pb.Layer4_Tcp{
                        Tcp: &amp;pb.TCP{
                                SourcePort:      protocol.TCP.SourcePort,
                                DestinationPort: protocol.TCP.DestinationPort,
                        },
                }</span>
        case *flow.Layer4_UDP:<span class="cov0" title="0">
                layer4.Protocol = &amp;pb.Layer4_Udp{
                        Udp: &amp;pb.UDP{
                                SourcePort:      protocol.UDP.SourcePort,
                                DestinationPort: protocol.UDP.DestinationPort,
                        },
                }</span>
        case *flow.Layer4_ICMPv4:<span class="cov0" title="0">
                layer4.Protocol = &amp;pb.Layer4_Icmpv4{
                        Icmpv4: &amp;pb.ICMPv4{
                                Type: protocol.ICMPv4.Type,
                                Code: protocol.ICMPv4.Code,
                        },
                }</span>
        case *flow.Layer4_ICMPv6:<span class="cov0" title="0">
                layer4.Protocol = &amp;pb.Layer4_Icmpv6{
                        Icmpv6: &amp;pb.ICMPv6{
                                Type: protocol.ICMPv6.Type,
                                Code: protocol.ICMPv6.Code,
                        },
                }</span>
        case *flow.Layer4_SCTP:<span class="cov0" title="0">
                layer4.Protocol = &amp;pb.Layer4_Sctp{
                        Sctp: &amp;pb.SCTP{
                                SourcePort:      protocol.SCTP.SourcePort,
                                DestinationPort: protocol.SCTP.DestinationPort,
                        },
                }</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">return layer4</span>
}

// convertCiliumWorkflows converts a slice of flow.Workload objects to a slice of pb.Workload objects.
func convertCiliumWorkflows(workloads []*flow.Workload) []*pb.Workload <span class="cov0" title="0">{
        protoWorkloads := make([]*pb.Workload, 0, len(workloads))
        for _, workload := range workloads </span><span class="cov0" title="0">{
                protoWorkload := &amp;pb.Workload{
                        Name: workload.GetName(),
                        Kind: workload.GetKind(),
                }
                protoWorkloads = append(protoWorkloads, protoWorkload)
        }</span>
        <span class="cov0" title="0">return protoWorkloads</span>
}

// convertCiliumPolicies converts a slice of flow.Policy objects to a slice of pb.Policy objects.
func convertCiliumPolicies(policies []*flow.Policy) []*pb.Policy <span class="cov0" title="0">{
        protoPolicies := make([]*pb.Policy, 0, len(policies))
        for _, policy := range policies </span><span class="cov0" title="0">{
                protoPolicy := &amp;pb.Policy{
                        Name:      policy.GetName(),
                        Namespace: policy.GetNamespace(),
                        Labels:    policy.GetLabels(),
                        Revision:  policy.GetRevision(),
                }
                protoPolicies = append(protoPolicies, protoPolicy)
        }</span>
        <span class="cov0" title="0">return protoPolicies</span>
}

// exportCiliumFlows makes one stream gRPC call to hubble-relay to collect, convert, and export flows into the given stream.
func (fm *CiliumFlowCollector) exportCiliumFlows(ctx context.Context, sm streamManager) error <span class="cov0" title="0">{
        req := &amp;observer.GetFlowsRequest{
                Number: ciliumHubbleRelayMaxFlowCount,
                Follow: true,
        }
        observerClient := fm.client
        stream, err := observerClient.GetFlows(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                fm.logger.Error("Error getting network flows", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                err = stream.CloseSend()
                if err != nil </span><span class="cov0" title="0">{
                        fm.logger.Error("Error closing observerClient stream", zap.Error(err))
                }</span>
        }()
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov0" title="0">flow, err := stream.Recv()
                if err != nil </span><span class="cov0" title="0">{
                        fm.logger.Warn("Failed to get flow log from stream", zap.Error(err))
                        return err
                }</span>
                <span class="cov0" title="0">ciliumFlow := convertCiliumFlow(flow)
                if ciliumFlow == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">err = sendNetworkFlowRequest(&amp;sm, ciliumFlow)
                if err != nil </span><span class="cov0" title="0">{
                        fm.logger.Error("Cannot send cilium flow", zap.Error(err))
                        return err
                }</span>
        }
}

// convertCiliumFlow converts a GetFlowsResponse object to a CiliumFlow object
func convertCiliumFlow(flow *observer.GetFlowsResponse) *pb.CiliumFlow <span class="cov0" title="0">{
        flowObj := flow.GetFlow()
        // Check for nil fields
        if flowObj.GetTime() == nil ||
                flowObj.GetNodeName() == "" ||
                flowObj.GetTrafficDirection().String() == "" ||
                flowObj.GetVerdict().String() == "" ||
                flowObj.GetIP() == nil ||
                flowObj.GetL4() == nil </span><span class="cov0" title="0">{
                // Return nil if any of the essential fields are nil
                return nil
        }</span>

        <span class="cov0" title="0">ciliumFlow := &amp;pb.CiliumFlow{
                Time:               flowObj.GetTime(),
                NodeName:           flowObj.GetNodeName(),
                Verdict:            pb.Verdict(flowObj.GetVerdict()),
                TrafficDirection:   pb.TrafficDirection(flowObj.GetTrafficDirection()),
                Layer3:             convertCiliumIP(flowObj.GetIP()),
                Layer4:             convertCiliumLayer4(flowObj.GetL4()),
                DestinationService: &amp;pb.Service{Name: flowObj.GetDestinationService().GetName(), Namespace: flowObj.GetDestinationService().GetNamespace()},
                EgressAllowedBy:    convertCiliumPolicies(flowObj.GetEgressAllowedBy()),
                IngressAllowedBy:   convertCiliumPolicies(flowObj.GetIngressAllowedBy()),
                EgressDeniedBy:     convertCiliumPolicies(flowObj.GetEgressDeniedBy()),
                IngressDeniedBy:    convertCiliumPolicies(flowObj.GetIngressDeniedBy()),
                IsReply:            flowObj.GetIsReply(),
        }
        if flowObj.GetSource() != nil </span><span class="cov0" title="0">{
                ciliumFlow.SourceEndpoint = &amp;pb.Endpoint{
                        Uid:         flowObj.GetSource().GetID(),
                        ClusterName: flowObj.GetSource().GetClusterName(),
                        Namespace:   flowObj.GetSource().GetNamespace(),
                        Labels:      flowObj.GetSource().GetLabels(),
                        PodName:     flowObj.GetSource().GetPodName(),
                        Workloads:   convertCiliumWorkflows(flowObj.GetSource().GetWorkloads()),
                }
        }</span>
        <span class="cov0" title="0">if flowObj.GetDestination() != nil </span><span class="cov0" title="0">{
                ciliumFlow.DestinationEndpoint = &amp;pb.Endpoint{
                        Uid:         flowObj.GetDestination().GetID(),
                        ClusterName: flowObj.GetDestination().GetClusterName(),
                        Namespace:   flowObj.GetDestination().GetNamespace(),
                        Labels:      flowObj.GetDestination().GetLabels(),
                        PodName:     flowObj.GetDestination().GetPodName(),
                        Workloads:   convertCiliumWorkflows(flowObj.GetDestination().GetWorkloads()),
                }
        }</span>
        <span class="cov0" title="0">return ciliumFlow</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2024 Illumio, Inc. All Rights Reserved.
package controller

import (
        "encoding/json"
        "net/http"
        "strconv"
        "strings"
        "time"

        pb "github.com/illumio/cloud-operator/api/illumio/cloud/k8sclustersync/v1"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// FalcoEvent represents the network information extracted from a Falco event.
type FalcoEvent struct {
        // Timestamp is the time the network event occured. ISO 8601 format
        Timestamp *timestamppb.Timestamp `json:"time"`
        // SrcIP is the source IP address involved in the network event.
        SrcIP string `json:"srcip"`
        // DstIP is the destination IP address involved in the network event.
        DstIP string `json:"dstip"`
        // SrcPort is the source port number involved in the network event.
        SrcPort string `json:"srcport"`
        // DstPort is the destination port number involved in the network event.
        DstPort string `json:"dstport"`
        // Proto is the protocol used in the network event (e.g., TCP, UDP).
        Proto string `json:"proto"`
        // IpVersion is the version used in the network event (e.g. ipv4, ipv6).
        IpVersion string `json:"prototype"`
}

// falcoTimestampFormat  is the format of timestamp strings received from Falco
const falcoTimestampFormat = "2006-01-02T15:04:05.999999999-0700"

// removeTrailingTab removes the trailing tab character from the input string if it exists.
// Within the falco network logs, the timestamp comes with a trailing '\t', this function
// trims that tab off before sending up to CloudSecure.
func removeTrailingTab(time string) string <span class="cov0" title="0">{
        return strings.TrimRight(time, "\t")
}</span>

// parseFalcoTimestamp  parses the input string value in a Falco's timestamp format that is similar to RFC3339 and returns a timestamppb.Timestamp.
func parseFalcoTimestamp(value string) (*timestamppb.Timestamp, error) <span class="cov0" title="0">{
        value = removeTrailingTab(value)

        // Parse the timestamp string using the specified layout
        t, err := time.Parse(falcoTimestampFormat, value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrFalcoTimestamp
        }</span>

        <span class="cov0" title="0">return timestamppb.New(t), nil</span>
}

// parsePodNetworkInfo parses the input string to extract network information into a FalcoFlow message.
func parsePodNetworkInfo(input string) (*pb.FalcoFlow, error) <span class="cov0" title="0">{
        var info FalcoEvent
        // Regular expression to extract the key-value pairs from the input string
        matches := reParsePodNetworkInfo.FindAllStringSubmatch(input, -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) == 3 </span><span class="cov0" title="0">{
                        key, value := match[1], match[2]
                        switch key </span>{
                        case "time":<span class="cov0" title="0">
                                ts, err := parseFalcoTimestamp(value)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">info.Timestamp = ts</span>
                        case "srcip":<span class="cov0" title="0">
                                info.SrcIP = value</span>
                        case "dstip":<span class="cov0" title="0">
                                info.DstIP = value</span>
                        case "srcport":<span class="cov0" title="0">
                                info.SrcPort = value</span>
                        case "dstport":<span class="cov0" title="0">
                                info.DstPort = value</span>
                        case "proto":<span class="cov0" title="0">
                                info.Proto = value</span>
                        case "ipversion":<span class="cov0" title="0">
                                info.IpVersion = value</span>
                        }
                }
        }
        <span class="cov0" title="0">if (FalcoEvent{}) == info </span><span class="cov0" title="0">{
                return nil, ErrFalcoEventIsNotFlow
        }</span>

        <span class="cov0" title="0">layer3Message, err := createLayer3Message(info.SrcIP, info.DstIP, info.IpVersion)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">srcPort, err := strconv.ParseUint(info.SrcPort, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrFalcoInvalidPort
        }</span>
        <span class="cov0" title="0">dstPort, err := strconv.ParseUint(info.DstPort, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrFalcoInvalidPort
        }</span>

        <span class="cov0" title="0">layer4Message, err := createLayer4Message(info.Proto, uint32(srcPort), uint32(dstPort), info.IpVersion)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">flow := &amp;pb.FalcoFlow{
                Layer3: layer3Message,
                Layer4: layer4Message,
                Ts: &amp;pb.FalcoFlow_Timestamp{
                        Timestamp: info.Timestamp,
                },
        }

        return flow, nil</span>

}

// NewFalcoEventHandler creates a new HTTP handler function for processing Falco events.
func NewFalcoEventHandler(eventChan chan&lt;- string) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                var body struct {
                        Output string `json:"output"`
                }
                if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">t := time.NewTimer(2 * time.Second)
                select </span>{
                case eventChan &lt;- body.Output:<span class="cov0" title="0">
                        w.WriteHeader(http.StatusOK)</span>
                case &lt;-r.Context().Done():<span class="cov0" title="0">
                        w.WriteHeader(http.StatusServiceUnavailable)</span>
                case &lt;-t.C:<span class="cov0" title="0">
                        w.WriteHeader(http.StatusServiceUnavailable)</span>
                }
                <span class="cov0" title="0">t.Stop()</span>
        }
}

// filterIllumioTraffic filters out events related to Illumio network traffic.
func filterIllumioTraffic(body string) bool <span class="cov0" title="0">{
        return strings.Contains(body, "illumio_network_traffic")
}</span>

func createLayer3Message(source string, destination string, ipVersion string) (*pb.IP, error) <span class="cov0" title="0">{
        if ipVersion == "ipv4" </span><span class="cov0" title="0">{
                return &amp;pb.IP{Source: source, Destination: destination, IpVersion: pb.IPVersion_IP_VERSION_IPV4}, nil
        }</span> else<span class="cov0" title="0"> if ipVersion == "ipv6" </span><span class="cov0" title="0">{
                return &amp;pb.IP{Source: source, Destination: destination, IpVersion: pb.IPVersion_IP_VERSION_IPV6}, nil
        }</span>
        // If this is IPVersion_IP_VERSION_IP_NOT_USED_UNSPECIFIED we want to drop this packet.
        <span class="cov0" title="0">return nil, ErrFalcoIncompleteL3Flow</span>
}

// createLayer4Message converts event protocol and ports to a Layer4 proto message
func createLayer4Message(proto string, srcPort, dstPort uint32, ipVersion string) (*pb.Layer4, error) <span class="cov0" title="0">{
        switch proto </span>{
        case "tcp":<span class="cov0" title="0">
                return &amp;pb.Layer4{
                        Protocol: &amp;pb.Layer4_Tcp{
                                Tcp: &amp;pb.TCP{
                                        SourcePort:      srcPort,
                                        DestinationPort: dstPort,
                                        Flags:           &amp;pb.TCPFlags{},
                                },
                        },
                }, nil</span>
        case "udp":<span class="cov0" title="0">
                return &amp;pb.Layer4{
                        Protocol: &amp;pb.Layer4_Udp{
                                Udp: &amp;pb.UDP{
                                        SourcePort:      srcPort,
                                        DestinationPort: dstPort,
                                },
                        },
                }, nil</span>
        case "icmp":<span class="cov0" title="0">
                if ipVersion == "ipv4" </span><span class="cov0" title="0">{
                        return &amp;pb.Layer4{
                                Protocol: &amp;pb.Layer4_Icmpv4{
                                        Icmpv4: &amp;pb.ICMPv4{},
                                },
                        }, nil
                }</span> else<span class="cov0" title="0"> if ipVersion == "ipv6" </span><span class="cov0" title="0">{
                        return &amp;pb.Layer4{
                                Protocol: &amp;pb.Layer4_Icmpv6{
                                        Icmpv6: &amp;pb.ICMPv6{},
                                },
                        }, nil
                }</span>
        default:<span class="cov0" title="0"></span>
        }
        <span class="cov0" title="0">return nil, ErrFalcoIncompleteL4Flow</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2024 Illumio, Inc. All Rights Reserved.

package controller

import (
        "fmt"
        "io"
        "os"
        "sync"
        "time"

        pb "github.com/illumio/cloud-operator/api/illumio/cloud/k8sclustersync/v1"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "google.golang.org/grpc/connectivity"
)

const (
        logMaxBufferSize = 2048
        logFlushInterval = 5 * time.Second
)

type ClientConnInterface interface {
        GetState() connectivity.State
        Close() error
}

// BufferedGrpcWriteSyncer is a custom zap writesync that writes to a grpc stream
// In case stream is not connected it will buffer to memory
type BufferedGrpcWriteSyncer struct {
        client              pb.KubernetesInfoService_SendLogsClient
        conn                ClientConnInterface
        buffer              []string
        mutex               sync.Mutex
        done                chan struct{}
        logger              *zap.Logger
        logLevel            zap.AtomicLevel
        encoder             zapcore.Encoder
        lostLogEntriesCount int
        lostLogEntriesErr   error
}

// NewBufferedGrpcWriteSyncer returns a new BufferedGrpcWriteSyncer
func NewBufferedGrpcWriteSyncer() *BufferedGrpcWriteSyncer <span class="cov0" title="0">{
        bws := &amp;BufferedGrpcWriteSyncer{
                client:              nil,
                conn:                nil,
                buffer:              make([]string, 0, logMaxBufferSize),
                done:                make(chan struct{}),
                lostLogEntriesCount: 0,
        }
        go bws.run()
        return bws
}</span>

// Close flushes buffered log data into grpc stream if possible, and closes the connection.
func (b *BufferedGrpcWriteSyncer) Close() error <span class="cov0" title="0">{
        b.mutex.Lock()
        defer b.mutex.Unlock()
        b.flush()
        // Close the channel if not already closed.
        select </span>{
        case &lt;-b.done:<span class="cov0" title="0">
                // Already closed; do nothing
                return nil</span>
        default:<span class="cov0" title="0"></span>
        }
        <span class="cov0" title="0">close(b.done)
        return b.conn.Close()</span>
}

// flush will attempt to dump buffer into GRPC stream if available
func (b *BufferedGrpcWriteSyncer) flush() <span class="cov8" title="1">{
        if len(b.buffer) == 0 || b.conn == nil || b.conn.GetState() != connectivity.Ready </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">if b.lostLogEntriesCount &gt; 0 </span><span class="cov0" title="0">{
                lostLogsMessage, err := encodeLogEntry(
                        b.encoder,
                        zapcore.Entry{
                                Level:   zap.ErrorLevel,
                                Time:    time.Now().UTC(),
                                Message: "Lost logs due to buffer overflow",
                        },
                        []zap.Field{
                                zap.Error(b.lostLogEntriesErr),
                                zap.Int("lost_log_entries", b.lostLogEntriesCount),
                        },
                )
                if err != nil </span><span class="cov0" title="0">{
                        b.lostLogEntriesErr = err
                        return
                }</span>

                <span class="cov0" title="0">if err := b.sendLogEntry(lostLogsMessage); err != nil </span><span class="cov0" title="0">{
                        b.lostLogEntriesErr = err
                        return
                }</span>
                <span class="cov0" title="0">b.lostLogEntriesCount = 0</span>
        }

        <span class="cov0" title="0">for _, jsonMessage := range b.buffer </span><span class="cov0" title="0">{
                if err := b.sendLogEntry(jsonMessage); err != nil </span><span class="cov0" title="0">{
                        b.lostLogEntriesCount += 1
                        b.lostLogEntriesErr = err
                }</span>
        }
        <span class="cov0" title="0">b.buffer = b.buffer[:0]</span>
}

// run flushes the buffer at the configured interval until Stop is called.
func (b *BufferedGrpcWriteSyncer) run() <span class="cov0" title="0">{
        ticker := time.NewTicker(logFlushInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        b.mutex.Lock()
                        b.flush()
                        b.mutex.Unlock()</span>
                case &lt;-b.done:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// encodeLogEntry encodes a log Entry and fields into a string using the given Encoder.
func encodeLogEntry(encoder zapcore.Encoder, logEntry zapcore.Entry, fields []zap.Field) (string, error) <span class="cov8" title="1">{
        buf, err := encoder.EncodeEntry(logEntry, fields)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encode log entry: %w", err)
        }</span>

        // Remove any newline added by Zap's encoder
        <span class="cov8" title="1">buf.TrimNewline()

        return buf.String(), nil</span>
}

// write sends a JSON-encoded log entry, or buffers it if there is no
// connection currently established to the server.
func (b *BufferedGrpcWriteSyncer) write(jsonMessage string) <span class="cov8" title="1">{
        // Do not use logging while locking this mutex to avoid deadlocks
        b.mutex.Lock()
        defer b.mutex.Unlock()

        var shouldBuffer bool

        if b.conn == nil || b.conn.GetState() != connectivity.Ready </span><span class="cov8" title="1">{
                shouldBuffer = true
        }</span> else<span class="cov8" title="1"> {
                // Flush buffered logs
                b.flush()
                if err := b.sendLogEntry(jsonMessage); err != nil </span><span class="cov0" title="0">{
                        shouldBuffer = true
                }</span>
        }

        <span class="cov8" title="1">if shouldBuffer </span><span class="cov8" title="1">{
                if len(b.buffer) &lt; cap(b.buffer) </span><span class="cov8" title="1">{
                        b.buffer = append(b.buffer, jsonMessage)
                }</span> else<span class="cov8" title="1"> {
                        b.lostLogEntriesCount += 1
                }</span>
        }
}

// sendLogEntry sends the log encoded into a string to the log server.
func (b *BufferedGrpcWriteSyncer) sendLogEntry(jsonMessage string) error <span class="cov8" title="1">{
        return b.client.Send(&amp;pb.SendLogsRequest{
                Request: &amp;pb.SendLogsRequest_LogEntry{
                        LogEntry: &amp;pb.LogEntry{
                                JsonMessage: jsonMessage,
                        },
                },
        })
}</span>

// UpdateClient updates the gRPC connection and connection in the BufferedGrpcWriteSyncer.
func (b *BufferedGrpcWriteSyncer) UpdateClient(client pb.KubernetesInfoService_SendLogsClient, conn ClientConnInterface) <span class="cov0" title="0">{
        b.mutex.Lock()
        b.client = client
        b.conn = conn
        b.flush()
        b.mutex.Unlock()
}</span>

// ListenToLogStream waits for responses from the server and updates the log level
// based on the contents of responses.
func (b *BufferedGrpcWriteSyncer) ListenToLogStream() error <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                res, err := b.client.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        // The client has closed the stream
                        b.logger.Info("Server closed the SendLogs stream")
                        return nil
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        b.logger.Error("Stream terminated", zap.Error(err))
                        return err
                }</span>
                <span class="cov0" title="0">switch res.Response.(type) </span>{
                case *pb.SendLogsResponse_SetLogLevel:<span class="cov0" title="0">
                        newLevel := res.GetSetLogLevel().Level
                        b.updateLogLevel(newLevel)</span>
                }
        }
}

// updateLogLevel sets the logger's log level based on the response from the server.
func (b *BufferedGrpcWriteSyncer) updateLogLevel(level pb.LogLevel) <span class="cov0" title="0">{
        switch level </span>{
        case pb.LogLevel_LOG_LEVEL_DEBUG:<span class="cov0" title="0">
                b.logger.Info("Set to DEBUG level log")
                b.logLevel.SetLevel(zapcore.DebugLevel)</span>
        case pb.LogLevel_LOG_LEVEL_ERROR:<span class="cov0" title="0">
                b.logger.Info("Set to ERROR level log")
                b.logLevel.SetLevel(zapcore.ErrorLevel)</span>
        case pb.LogLevel_LOG_LEVEL_INFO:<span class="cov0" title="0">
                b.logger.Info("Set to INFO level log")
                b.logLevel.SetLevel(zapcore.InfoLevel)</span>
        case pb.LogLevel_LOG_LEVEL_WARN:<span class="cov0" title="0">
                b.logger.Info("Set to WARN level log")
                b.logLevel.SetLevel(zapcore.WarnLevel)</span>
        default:<span class="cov0" title="0">
                b.logger.Warn("Unknown log level received, defaulting to INFO")
                b.logLevel.SetLevel(zapcore.InfoLevel)</span>
        }
}

// zapCoreWrapper wraps a zapcore.Core to duplicate log entries into a BufferedGrpcWriteSyncer
type zapCoreWrapper struct {
        core       zapcore.Core
        encoder    zapcore.Encoder
        grpcSyncer *BufferedGrpcWriteSyncer
}

var _ zapcore.Core = &amp;zapCoreWrapper{}

func (w *zapCoreWrapper) Check(entry zapcore.Entry, ce *zapcore.CheckedEntry) *zapcore.CheckedEntry <span class="cov8" title="1">{
        if downstream := w.core.Check(entry, ce); downstream != nil </span><span class="cov8" title="1">{
                return downstream.AddCore(entry, w)
        }</span>
        <span class="cov0" title="0">return ce</span>
}

func (w *zapCoreWrapper) Enabled(level zapcore.Level) bool <span class="cov8" title="1">{
        return w.core.Enabled(level)
}</span>

func (w *zapCoreWrapper) Sync() error <span class="cov0" title="0">{
        return w.core.Sync()
}</span>

func (w *zapCoreWrapper) With(fields []zapcore.Field) zapcore.Core <span class="cov8" title="1">{
        newWrapper := &amp;zapCoreWrapper{
                core:       w.core.With(fields),
                encoder:    w.encoder.Clone(),
                grpcSyncer: w.grpcSyncer,
        }
        for i := range fields </span><span class="cov8" title="1">{
                fields[i].AddTo(newWrapper.encoder)
        }</span>
        <span class="cov8" title="1">return newWrapper</span>
}

func (w *zapCoreWrapper) Write(entry zapcore.Entry, fields []zapcore.Field) error <span class="cov8" title="1">{
        // Encode the entry immediately and never refer to the Entry and Fields afterwards,
        // as it is more compact and the fields can be garbage-collected while the entry is buffered.
        jsonMessage, err := encodeLogEntry(w.encoder, entry, fields)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">w.grpcSyncer.write(jsonMessage)

        return nil</span>
}

// NewGRPCLogger creates a Zap logger with multiple writesyncs:
// one to stdout and one for GRPC writestream
func NewGRPCLogger(grpcSyncer *BufferedGrpcWriteSyncer, addCaller bool, clock zapcore.Clock) *zap.Logger <span class="cov8" title="1">{
        // Create a production encoder config
        encoderConfig := zap.NewProductionEncoderConfig()

        // Modify the time format to be more human-readable
        encoderConfig.EncodeTime = zapcore.TimeEncoder(func(t time.Time, enc zapcore.PrimitiveArrayEncoder) </span><span class="cov8" title="1">{
                enc.AppendString(t.Format(time.RFC3339))
        }</span>)

        // Create a JSON encoder
        <span class="cov8" title="1">encoder := zapcore.NewJSONEncoder(encoderConfig)

        // Create syncers for console output
        consoleSyncer := zapcore.AddSync(os.Stdout)

        // Initialize the atomic level
        atomicLevel := zap.NewAtomicLevelAt(zapcore.InfoLevel)

        consoleCore := zapcore.NewCore(encoder, consoleSyncer, atomicLevel)

        // Create zap logger with the console core
        logger := zap.New(
                &amp;zapCoreWrapper{
                        core:       consoleCore,
                        encoder:    encoder,
                        grpcSyncer: grpcSyncer,
                },
                zap.WithCaller(addCaller),
                zap.AddStacktrace(zapcore.ErrorLevel),
                zap.WithClock(clock),
        )

        grpcSyncer.logger = logger
        grpcSyncer.logLevel = atomicLevel
        grpcSyncer.encoder = encoder
        return logger</span>
}

// NewProductionGRPCLogger creates a Zap logger configured for production.
func NewProductionGRPCLogger(grpcSyncer *BufferedGrpcWriteSyncer) *zap.Logger <span class="cov0" title="0">{
        return NewGRPCLogger(grpcSyncer, true, zapcore.DefaultClock)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2024 Illumio, Inc. All Rights Reserved.

package controller

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"

        pb "github.com/illumio/cloud-operator/api/illumio/cloud/k8sclustersync/v1"
        "go.uber.org/zap"
        "google.golang.org/protobuf/types/known/timestamppb"
        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/meta"
        "k8s.io/client-go/kubernetes"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
)

// convertObjectToMetadata extracts the ObjectMeta from a metav1.Object interface.
func convertObjectToMetadata(obj metav1.Object) metav1.ObjectMeta <span class="cov8" title="1">{
        objMetadata := metav1.ObjectMeta{
                Name:            obj.GetName(),
                Namespace:       obj.GetNamespace(),
                UID:             obj.GetUID(),
                ResourceVersion: obj.GetResourceVersion(),
                Labels:          obj.GetLabels(),
                Annotations:     obj.GetAnnotations(),
        }
        return objMetadata
}</span>

// getObjectMetadataFromRuntimeObject safely extracts metadata from any Kubernetes runtime.Object.
// It returns a pointer to a metav1.ObjectMeta structure if successful, along with any error encountered.
func getObjectMetadataFromRuntimeObject(obj runtime.Object) (*metav1.ObjectMeta, error) <span class="cov8" title="1">{
        objectMeta, err := meta.Accessor(obj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">convertedObjMeta := convertObjectToMetadata(objectMeta)
        return &amp;convertedObjMeta, nil</span>
}

// getMetadatafromResource extracts the metav1.ObjectMeta from an unstructured.Unstructured resource.
// It utilizes the unstructured's inherent methods to access the metadata directly.
func getMetadatafromResource(logger *zap.Logger, resource unstructured.Unstructured) (*metav1.ObjectMeta, error) <span class="cov8" title="1">{
        // Convert unstructured object to a map.
        itemMap := resource.Object
        // Extract metadata from map.
        if metadata, found := itemMap["metadata"].(map[string]interface{}); found </span><span class="cov8" title="1">{
                // Convert the metadata map to JSON and then unmarshal into metav1.ObjectMeta.
                metadataJSON, err := json.Marshal(metadata)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error marshalling metadata", zap.Error(err))
                        return &amp;metav1.ObjectMeta{}, err
                }</span>
                <span class="cov8" title="1">var objectMeta metav1.ObjectMeta
                if err := json.Unmarshal(metadataJSON, &amp;objectMeta); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error unmarshalling metadata", zap.Error(err))
                        return &amp;metav1.ObjectMeta{}, err
                }</span>
                <span class="cov8" title="1">return &amp;objectMeta, err</span>
        } else<span class="cov0" title="0"> {
                return &amp;metav1.ObjectMeta{}, errors.New("could not grab metadata from a resource")
        }</span>
}

// convertMetaObjectToMetadata takes a metav1.ObjectMeta and converts it into a proto message object KubernetesMetadata.
func convertMetaObjectToMetadata(logger *zap.Logger, ctx context.Context, obj metav1.ObjectMeta, clientset *kubernetes.Clientset, resource string) (*pb.KubernetesObjectData, error) <span class="cov0" title="0">{
        ownerReferences, err := convertOwnerReferences(obj.GetOwnerReferences())
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("cannot convert OwnerReferences", zap.Error(err))
                return &amp;pb.KubernetesObjectData{}, fmt.Errorf("cannot convert OwnerReferences")
        }</span>
        <span class="cov0" title="0">objMetadata := &amp;pb.KubernetesObjectData{
                Annotations:       obj.GetAnnotations(),
                CreationTimestamp: convertToProtoTimestamp(obj.CreationTimestamp),
                Kind:              resource,
                Labels:            obj.GetLabels(),
                Name:              obj.GetName(),
                Namespace:         obj.GetNamespace(),
                OwnerReferences:   ownerReferences,
                ResourceVersion:   obj.GetResourceVersion(),
                Uid:               string(obj.GetUID()),
        }
        switch resource </span>{
        case "Pod":<span class="cov0" title="0">
                hostIPs, err := getPodIPAddresses(ctx, obj.GetName(), clientset, obj.GetNamespace())
                if err != nil </span><span class="cov0" title="0">{
                        return objMetadata, nil
                }</span>
                <span class="cov0" title="0">objMetadata.KindSpecific = &amp;pb.KubernetesObjectData_Pod{Pod: &amp;pb.KubernetesPodData{IpAddresses: convertHostIPsToStrings(hostIPs)}}</span>
        case "Node":<span class="cov0" title="0">
                providerId, err := getProviderIdNodeSpec(ctx, clientset, obj.GetName())
                if err != nil </span><span class="cov0" title="0">{
                        return objMetadata, nil
                }</span>
                <span class="cov0" title="0">ipAddresses, err := getNodeIpAddresses(ctx, clientset, obj.GetName())
                if err != nil </span><span class="cov0" title="0">{
                        return objMetadata, nil
                }</span>
                <span class="cov0" title="0">objMetadata.KindSpecific = &amp;pb.KubernetesObjectData_Node{Node: &amp;pb.KubernetesNodeData{ProviderId: providerId, IpAddresses: ipAddresses}}</span>
        case "Service":<span class="cov0" title="0">
                convertedServiceData, err := convertToKubernetesServiceData(ctx, obj.GetName(), clientset, obj.GetNamespace())
                if err != nil </span><span class="cov0" title="0">{
                        return objMetadata, nil
                }</span>
                <span class="cov0" title="0">objMetadata.KindSpecific = &amp;pb.KubernetesObjectData_Service{Service: convertedServiceData}</span>

        }
        <span class="cov0" title="0">return objMetadata, nil</span>
}

// getNodeIpAddresses fetches the IP addresses of a node
func getNodeIpAddresses(ctx context.Context, clientset *kubernetes.Clientset, nodeName string) ([]string, error) <span class="cov0" title="0">{
        node, err := clientset.CoreV1().Nodes().Get(ctx, nodeName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to get node")
        }</span>
        <span class="cov0" title="0">ipAddresses := []string{}
        for _, address := range node.Status.Addresses </span><span class="cov0" title="0">{
                // We are excluding hostnames
                if address.Type == v1.NodeInternalIP || address.Type == v1.NodeExternalIP </span><span class="cov0" title="0">{
                        ipAddresses = append(ipAddresses, address.Address)
                }</span>
        }
        <span class="cov0" title="0">return ipAddresses, nil</span>
}

// convertIngressToStringList converts an array of v1.LoadBalancerIngress to a string array
func convertIngressToStringList(ingresses []v1.LoadBalancerIngress) []string <span class="cov0" title="0">{
        result := []string{}
        for _, ingress := range ingresses </span><span class="cov0" title="0">{
                if ingress.IP != "" </span><span class="cov0" title="0">{
                        result = append(result, ingress.IP)
                }</span>
                <span class="cov0" title="0">if ingress.Hostname != "" </span><span class="cov0" title="0">{
                        result = append(result, ingress.Hostname)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// convertServicePortsToPorts coverts an array of v1.ServicePort objects to a proto message KubernetesServiceData_ServicePort
func convertServicePortsToPorts(servicePorts []v1.ServicePort) []*pb.KubernetesServiceData_ServicePort <span class="cov0" title="0">{
        ports := make([]*pb.KubernetesServiceData_ServicePort, 0, len(servicePorts))
        for _, sp := range servicePorts </span><span class="cov0" title="0">{
                protocol := string(sp.Protocol)
                if protocol == "" </span><span class="cov0" title="0">{
                        protocol = string(v1.ProtocolTCP)
                }</span>
                <span class="cov0" title="0">port := &amp;pb.KubernetesServiceData_ServicePort{
                        Port:     uint32(sp.Port),
                        Protocol: protocol,
                }
                if sp.NodePort != 0 </span><span class="cov0" title="0">{
                        port.NodePort = int32ToUint32(&amp;sp.NodePort)
                }</span>
                <span class="cov0" title="0">ports = append(ports, port)</span>
        }
        <span class="cov0" title="0">return ports</span>
}

// int32ToUint32 converts *int32 to *uint32
func int32ToUint32(i *int32) *uint32 <span class="cov0" title="0">{
        if i == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">val := uint32(*i)
        return &amp;val</span>
}

// Combine all IPs into a single list
func combineIPAddresses(clusterIps []string, externalIps []string, loadBalancerIngresses []string, loadBalancerIp string) []string <span class="cov0" title="0">{
        combinedIPs := make([]string, 0, len(clusterIps)+len(externalIps)+len(loadBalancerIngresses)+1)
        combinedIPs = append(combinedIPs, clusterIps...)
        combinedIPs = append(combinedIPs, externalIps...)
        combinedIPs = append(combinedIPs, loadBalancerIngresses...)
        if loadBalancerIp != "" </span><span class="cov0" title="0">{
                combinedIPs = append(combinedIPs, loadBalancerIp)
        }</span>
        <span class="cov0" title="0">return combinedIPs</span>
}

// Convert ServiceAttributes to KubernetesServiceData
func convertToKubernetesServiceData(ctx context.Context, serviceName string, clientset *kubernetes.Clientset, namespace string) (*pb.KubernetesServiceData, error) <span class="cov0" title="0">{
        service, err := clientset.CoreV1().Services(namespace).Get(ctx, serviceName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("failed to get service")
        }</span>
        <span class="cov0" title="0">loadBalancerIngress := []string{}
        if len(service.Status.LoadBalancer.Ingress) &gt; 0 </span><span class="cov0" title="0">{
                loadBalancerIngress = convertIngressToStringList(service.Status.LoadBalancer.Ingress)
        }</span>
        <span class="cov0" title="0">ports := convertServicePortsToPorts(service.Spec.Ports)
        // Combine all IPs
        combinedIPs := combineIPAddresses(service.Spec.ClusterIPs, service.Spec.ExternalIPs, loadBalancerIngress, service.Spec.LoadBalancerIP)

        // Convert NodePorts to ServicePorts
        servicePorts := make([]*pb.KubernetesServiceData_ServicePort, len(ports))
        for i, np := range ports </span><span class="cov0" title="0">{
                var nodePort *uint32
                if np.NodePort != nil </span><span class="cov0" title="0">{
                        nodePortValue := uint32(*np.NodePort)
                        nodePort = &amp;nodePortValue
                }</span>
                <span class="cov0" title="0">servicePorts[i] = &amp;pb.KubernetesServiceData_ServicePort{
                        NodePort:          nodePort,
                        Port:              uint32(np.Port),
                        Protocol:          np.Protocol,
                        LoadBalancerPorts: np.LoadBalancerPorts,
                }</span>
        }

        <span class="cov0" title="0">return &amp;pb.KubernetesServiceData{
                IpAddresses:       combinedIPs,
                Ports:             servicePorts,
                Type:              string(service.Spec.Type),
                ExternalName:      &amp;service.Spec.ExternalName,
                LoadBalancerClass: service.Spec.LoadBalancerClass,
        }, nil</span>
}

// convertOwnerReferences converts a slice of Kubernetes OwnerReference objects into a slice of
// protobuf KubernetesOwnerReference objects.
func convertOwnerReferences(ownerReferences []metav1.OwnerReference) ([]*pb.KubernetesOwnerReference, error) <span class="cov0" title="0">{
        if len(ownerReferences) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">result := make([]*pb.KubernetesOwnerReference, 0, len(ownerReferences))
        for _, ownerRef := range ownerReferences </span><span class="cov0" title="0">{
                // Safely checking for nil values
                var blockOwnerDeletion bool
                if ownerRef.BlockOwnerDeletion != nil </span><span class="cov0" title="0">{
                        blockOwnerDeletion = *ownerRef.BlockOwnerDeletion
                }</span>

                <span class="cov0" title="0">var controller bool
                if ownerRef.Controller != nil </span><span class="cov0" title="0">{
                        controller = *ownerRef.Controller
                }</span>

                <span class="cov0" title="0">k8sOwnerRef := &amp;pb.KubernetesOwnerReference{
                        ApiVersion:         ownerRef.APIVersion,
                        BlockOwnerDeletion: blockOwnerDeletion,
                        Controller:         controller,
                        Kind:               ownerRef.Kind,
                        Name:               ownerRef.Name,
                        Uid:                string(ownerRef.UID),
                }
                result = append(result, k8sOwnerRef)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// getProviderIdNodeSpec uses a node name to return the providerID within the node's spec
func getProviderIdNodeSpec(ctx context.Context, clientset *kubernetes.Clientset, nodeName string) (string, error) <span class="cov0" title="0">{
        node, err := clientset.CoreV1().Nodes().Get(ctx, nodeName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">if node.Spec.ProviderID != "" </span><span class="cov0" title="0">{
                return node.Spec.ProviderID, nil
        }</span>
        <span class="cov0" title="0">return "", errors.New("no providerID set")</span>
}

// getPodIPAddresses uses a pod name and namespace to grab the hostIP addresses within the podStatus
func getPodIPAddresses(ctx context.Context, podName string, clientset *kubernetes.Clientset, namespace string) ([]v1.HostIP, error) <span class="cov0" title="0">{
        pod, err := clientset.CoreV1().Pods(namespace).Get(ctx, podName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                // Could be that the pod no longer exists
                return []v1.HostIP{}, nil
        }</span>
        <span class="cov0" title="0">if pod.Status.HostIPs != nil </span><span class="cov0" title="0">{
                return pod.Status.HostIPs, nil
        }</span>
        <span class="cov0" title="0">return []v1.HostIP{}, nil</span>
}

// convertHostIPsToStrings converts a slice of v1.HostIP to a slice of strings
func convertHostIPsToStrings(hostIPs []v1.HostIP) []string <span class="cov8" title="1">{
        stringIPs := make([]string, len(hostIPs))
        for i, hostIP := range hostIPs </span><span class="cov8" title="1">{
                stringIPs[i] = hostIP.IP
        }</span>
        <span class="cov8" title="1">return stringIPs</span>
}

// convertToProtoTimestamp converts a Kubernetes metav1.Time into a Protobuf Timestamp.
func convertToProtoTimestamp(k8sTime metav1.Time) *timestamppb.Timestamp <span class="cov8" title="1">{
        return timestamppb.New(k8sTime.Time)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2024 Illumio, Inc. All Rights Reserved.

package controller

import (
        "bytes"
        "context"
        "crypto/tls"
        "encoding/json"
        "errors"
        "io"
        "net/http"
        "time"

        "go.uber.org/zap"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type OnboardResponse struct {
        ClusterClientId     string `json:"cluster_client_id"`
        ClusterClientSecret string `json:"cluster_client_secret"`
}

// Onboard onboards this cluster with CloudSecure using the onboarding credentials and obtains OAuth 2 credentials for this cluster.
func Onboard(ctx context.Context, TlsSkipVerify bool, OnboardingEndpoint string, credentials Credentials, logger *zap.Logger) (OnboardResponse, error) <span class="cov0" title="0">{
        tlsConfig := &amp;tls.Config{
                MinVersion:         tls.VersionTLS12,
                InsecureSkipVerify: TlsSkipVerify,
        }
        transport := &amp;http.Transport{
                TLSClientConfig: tlsConfig,
        }
        client := &amp;http.Client{
                Transport: transport,
                Timeout:   5 * time.Second,
        }
        // Define the URL to which the POST request will be made

        // Create the data to be sent in the POST request
        data := map[string]string{
                "onboardingClientId":     credentials.ClientID,
                "onboardingClientSecret": credentials.ClientSecret,
        }
        var responseData OnboardResponse
        // Convert the data to JSON
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Unable to marshal json data", zap.Error(err))
                return responseData, err
        }</span>

        // Create a new POST request with the JSON data
        <span class="cov0" title="0">req, err := http.NewRequest("POST", OnboardingEndpoint, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Unable to structure post request", zap.Error(err))
                return responseData, err
        }</span>

        // Set the appropriate headers
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Unable to send post request", zap.Error(err))
                return responseData, err
        }</span>

        <span class="cov0" title="0">switch resp.StatusCode </span>{
        case http.StatusOK:<span class="cov0" title="0"></span>
                // 200 OK - Continue processing the response
        case http.StatusUnauthorized:<span class="cov0" title="0">
                // 401 Unauthorized
                err := errors.New("unauthorized: invalid credentials")
                logger.Error("Received 401 Unauthorized",
                        zap.Error(err),
                        zap.Int("status_code", http.StatusUnauthorized),
                        zap.String("description", "invalid credentials"),
                )
                return responseData, err</span>
        case http.StatusInternalServerError:<span class="cov0" title="0">
                // 500 Internal Server Error
                err := errors.New("internal server error: something went wrong on the server")
                logger.Error("Received 500 Internal Server Error",
                        zap.Error(err),
                        zap.Int("status_code", http.StatusInternalServerError),
                        zap.String("description", "something went wrong on the server"),
                )
                return responseData, err</span>
        default:<span class="cov0" title="0">
                // Handle other status codes
                err := errors.New("unexpected status code")
                logger.Error("Received unexpected status code",
                        zap.Error(err),
                        zap.Int("status_code", resp.StatusCode),
                )
                return responseData, err</span>
        }
        <span class="cov0" title="0">defer resp.Body.Close()
        // Read the response body
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Unable to read response of onboard post request", zap.Error(err))
                return responseData, err
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal(body, &amp;responseData); err != nil </span><span class="cov0" title="0">{
                logger.Error("Unable to unmarshal json data", zap.Error(err))
                return responseData, err
        }</span>
        <span class="cov0" title="0">return responseData, nil</span>
}

// getFirstAudience extracts the first audience from the claims map
func getFirstAudience(logger *zap.Logger, claims map[string]interface{}) (string, error) <span class="cov0" title="0">{
        aud, ok := claims["aud"]
        if !ok </span><span class="cov0" title="0">{
                err := errors.New("audience claim not found")
                logger.Error("Error extracting audience claim",
                        zap.Error(err),
                )
                return "", err
        }</span>

        <span class="cov0" title="0">audSlice, ok := aud.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                err := errors.New("audience claim is not a slice")
                logger.Error("Error extracting audience claim",
                        zap.Error(err),
                        zap.Any("aud", aud),
                )
                return "", err
        }</span>

        <span class="cov0" title="0">if len(audSlice) == 0 </span><span class="cov0" title="0">{
                err := errors.New("audience slice is empty")
                logger.Error("Error extracting audience claim",
                        zap.Error(err),
                )
                return "", err
        }</span>

        <span class="cov0" title="0">firstAud, ok := audSlice[0].(string)
        if !ok </span><span class="cov0" title="0">{
                err := errors.New("first audience claim is not a string")
                logger.Error("Error extracting audience claim",
                        zap.Error(err),
                        zap.Any("first_aud", audSlice[0]),
                )
                return "", err
        }</span>

        <span class="cov0" title="0">return firstAud, nil</span>
}

// GetClusterID returns the uid of the k8s cluster's kube-system namespace, which is used as the cluster's globally unique ID.
func GetClusterID(ctx context.Context, logger *zap.Logger) (string, error) <span class="cov0" title="0">{
        clientset, err := NewClientSet()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error creating clientset", zap.Error(err))
        }</span>
        <span class="cov0" title="0">namespace, err := clientset.CoreV1().Namespaces().Get(ctx, "kube-system", v1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Could not find kube-system namespace", zap.Error(err))
        }</span>
        <span class="cov0" title="0">return string(namespace.UID), nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright 2024 Illumio, Inc. All Rights Reserved.
package controller

import (
        "context"
        "fmt"
        "strings"
        "sync"

        "go.uber.org/zap"
        "golang.org/x/time/rate"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/watch"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/kubernetes"
)

// ResourceManager encapsulates components for listing and managing Kubernetes resources.
type ResourceManager struct {
        // Clientset providing accees to k8s api.
        clientset *kubernetes.Clientset
        // Logger provides strucuted logging interface.
        logger *zap.Logger
        // DynamicClient offers generic Kubernetes API operations.
        dynamicClient dynamic.Interface
        // streamManager abstracts logic related to starting, using, and managing streams.
        streamManager *streamManager
}

// TODO: Make a struct with the ClientSet as a field, and convertMetaObjectToMetadata, getPodIPAddresses, getProviderIdNodeSpec should be methods of that struct.

// DynamicListAndWatchResources lists and watches the specified resource
// dynamically, managing context cancellation and synchronization with wait
// groups. As long as we are able to watch and stream, we will never return from
// this function
func (r *ResourceManager) DynamicListAndWatchResources(ctx context.Context, cancel context.CancelFunc, resource string, apiGroup string, allResourcesSnapshotted *sync.WaitGroup, snapshotCompleted *sync.WaitGroup) <span class="cov0" title="0">{
        defer cancel()

        resourceListVersion, err := r.DynamicListResources(ctx, resource, apiGroup)
        if err != nil </span><span class="cov0" title="0">{
                allResourcesSnapshotted.Done()
                r.logger.Error("Unable to list resources", zap.Error(err))
                return
        }</span>
        <span class="cov0" title="0">allResourcesSnapshotted.Done()
        snapshotCompleted.Wait()

        // Here intiatate the watch event
        watchOptions := metav1.ListOptions{
                Watch:           true,
                ResourceVersion: resourceListVersion,
        }

        // Prevent us from overwhelming K8 api
        limiter := rate.NewLimiter(1, 5)
        err = limiter.Wait(ctx)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Cannot wait using rate limiter", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">err = r.watchEvents(ctx, resource, apiGroup, watchOptions)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}

// DynamicListResources lists a specifed resource dynamically and sends down the current gRPC stream.
func (r *ResourceManager) DynamicListResources(ctx context.Context, resource string, apiGroup string) (string, error) <span class="cov0" title="0">{
        objGVR := schema.GroupVersionResource{Group: apiGroup, Version: "v1", Resource: resource}
        objs, resourceListVersion, resourceK8sKind, err := r.ListResources(ctx, objGVR, metav1.NamespaceAll)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">for _, obj := range objs </span><span class="cov0" title="0">{
                metadataObj, err := convertMetaObjectToMetadata(r.logger, ctx, obj, r.clientset, resourceK8sKind)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Cannot convert object metadata", zap.Error(err))
                        return "", err
                }</span>
                <span class="cov0" title="0">err = sendObjectData(r.streamManager, metadataObj)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Cannot send object metadata", zap.Error(err))
                        return "", err
                }</span>
        }

        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return "", err</span>
        default:<span class="cov0" title="0"></span>
        }
        <span class="cov0" title="0">return resourceListVersion, nil</span>
}

// getErrFromWatchEvent returns an error if the watch event is of type Error.
// Includes the 'code', 'reason', and 'message'. If the watch event is NOT of
// type Error then return nil
func getErrFromWatchEvent(event watch.Event) error <span class="cov0" title="0">{
        if event.Object == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if event.Type != watch.Error </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">status, ok := event.Object.(*metav1.Status)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected error type: %T", event.Object)
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("code: %d, reason: %s, message: %s", status.Code, status.Reason, status.Message)</span>
}

// watchEvents watches Kubernetes resources. The second part of the of the "list
// and watch" strategy.
// Any occurring errors are sent through errChanWatch. The watch stops when ctx is cancelled.
func (r *ResourceManager) watchEvents(ctx context.Context, resource string, apiGroup string, watchOptions metav1.ListOptions) error <span class="cov0" title="0">{
        logger := r.logger.With(
                zap.String("api_group", apiGroup),
                zap.String("resource", resource),
        )

        objGVR := schema.GroupVersionResource{Group: apiGroup, Version: "v1", Resource: resource}
        watcher, err := r.dynamicClient.Resource(objGVR).Namespace(metav1.NamespaceAll).Watch(ctx, watchOptions)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error setting up watch on resource", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Debug("Disconnected from CloudSecure",
                                zap.String("reason", "context cancelled"),
                        )
                        return ctx.Err()</span>

                case event := &lt;-watcher.ResultChan():<span class="cov0" title="0">
                        // Exhaustive enum check on event type. We only want to report mutations
                        switch event.Type </span>{
                        case watch.Error:<span class="cov0" title="0">
                                err := getErrFromWatchEvent(event)
                                logger.Error("Watcher event has returned an error", zap.Error(err))
                                return err</span>
                        case watch.Bookmark:<span class="cov0" title="0">
                                continue</span>
                        case watch.Added, watch.Modified, watch.Deleted:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0">
                                logger.Debug("Received unknown watch event", zap.String("type", string(event.Type)))
                                continue</span>
                        }

                        // Type gymnastics: turn the watch.Event into a 'KubernetesObjectData'
                        <span class="cov0" title="0">convertedData, err := getObjectMetadataFromRuntimeObject(event.Object)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("Cannot convert runtime.Object to metav1.ObjectMeta", zap.Error(err))
                                return err
                        }</span>
                        <span class="cov0" title="0">resource := event.Object.GetObjectKind().GroupVersionKind().Kind
                        metadataObj, err := convertMetaObjectToMetadata(logger, ctx, *convertedData, r.clientset, resource)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("Cannot convert object metadata", zap.Error(err))
                                return err
                        }</span>

                        // Helper function: type gymnastics + send the KubernetesObjectData out on the wire
                        <span class="cov0" title="0">err = streamMutationObjectData(r.streamManager, metadataObj, event.Type)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("Cannot send resource mutation", zap.Error(err))
                                return err
                        }</span>
                }
        }
}

// FetchResources retrieves unstructured resources from the K8s API.
func (r *ResourceManager) FetchResources(ctx context.Context, resource schema.GroupVersionResource, namespace string) (*unstructured.UnstructuredList, error) <span class="cov0" title="0">{
        unstructuredResources, err := r.dynamicClient.Resource(resource).Namespace(namespace).List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("Cannot list resource", zap.Stringer("kind", resource), zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return unstructuredResources, nil</span>
}

// ExtractObjectMetas extracts ObjectMeta from a list of unstructured resources.
func (r *ResourceManager) ExtractObjectMetas(resources *unstructured.UnstructuredList) ([]metav1.ObjectMeta, error) <span class="cov0" title="0">{
        objectMetas := make([]metav1.ObjectMeta, 0, len(resources.Items))
        for _, item := range resources.Items </span><span class="cov0" title="0">{
                objMeta, err := getMetadatafromResource(r.logger, item)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("Cannot get Metadata from resource", zap.Error(err))
                        return nil, err
                }</span>
                <span class="cov0" title="0">objectMetas = append(objectMetas, *objMeta)</span>
        }
        <span class="cov0" title="0">return objectMetas, nil</span>
}

// ListResources fetches resources of a specified type and namespace, returning their ObjectMeta,
// the last resource version observed, and any error encountered.
func (r *ResourceManager) ListResources(ctx context.Context, resource schema.GroupVersionResource, namespace string) ([]metav1.ObjectMeta, string, string, error) <span class="cov0" title="0">{
        unstructuredResources, err := r.FetchResources(ctx, resource, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", "", err
        }</span>

        <span class="cov0" title="0">objectMetas, err := r.ExtractObjectMetas(unstructuredResources)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", "", err
        }</span>

        <span class="cov0" title="0">return objectMetas, unstructuredResources.GetResourceVersion(), removeListSuffix(unstructuredResources.GetKind()), nil</span>
}

// removeListSuffix removes the "List" suffix from a given string
// Ex: PodList -&gt; Pod, StafefulSetList -&gt; StatefulSet
func removeListSuffix(s string) string <span class="cov8" title="1">{
        if strings.HasSuffix(s, "List") </span><span class="cov8" title="1">{
                return s[:len(s)-4] // Remove the last 4 characters ("List")
        }</span>
        <span class="cov8" title="1">return s</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright 2024 Illumio, Inc. All Rights Reserved.

package controller

import (
        "context"
        "errors"
        "math"
        "math/rand"
        "net"
        "net/http"
        "regexp"
        "sync"
        "time"

        "go.uber.org/zap"
        "google.golang.org/grpc"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/rest"

        pb "github.com/illumio/cloud-operator/api/illumio/cloud/k8sclustersync/v1"
)

type StreamType string

const (
        STREAM_NETWORK_FLOWS = StreamType("network_flows")
        STREAM_RESOURCES     = StreamType("resources")
        STREAM_LOGS          = StreamType("logs")
        STREAM_CONFIGURATION = StreamType("configuration")
)

type streamClient struct {
        ciliumNamespace           string
        conn                      *grpc.ClientConn
        client                    pb.KubernetesInfoServiceClient
        disableNetworkFlowsCilium bool
        falcoEventChan            chan string
        flowCollector             pb.FlowCollector
        flowCollectorWG           sync.WaitGroup
        logStream                 pb.KubernetesInfoService_SendLogsClient
        networkFlowsStream        pb.KubernetesInfoService_SendKubernetesNetworkFlowsClient
        resourceStream            pb.KubernetesInfoService_SendKubernetesResourcesClient
}

type deadlockDetector struct {
        mutex               sync.RWMutex
        processingResources bool
        timeStarted         time.Time
}

type streamManager struct {
        bufferedGrpcSyncer *BufferedGrpcWriteSyncer
        logger             *zap.Logger
        streamClient       *streamClient
}

type KeepalivePeriods struct {
        KubernetesNetworkFlows time.Duration
        Logs                   time.Duration
        KubernetesResources    time.Duration
}

type EnvironmentConfig struct {
        // Namspace of Cilium.
        CiliumNamespace string
        // K8s cluster secret name.
        ClusterCreds string
        // Client ID for onboarding. "" if not specified, i.e. if the operator is not meant to onboard itself.
        OnboardingClientId string
        // Client secret for onboarding. "" if not specified, i.e. if the operator is not meant to onboard itself.
        OnboardingClientSecret string
        // URL of the onboarding endpoint.
        OnboardingEndpoint string
        // URL of the token endpoint.
        TokenEndpoint string
        // Whether to skip TLS certificate verification when starting a stream.
        TlsSkipVerify bool
        // KeepalivePeriods specifies the period (minus jitter) between two keepalives sent on each stream
        KeepalivePeriods KeepalivePeriods
}

var resourceAPIGroupMap = map[string]string{
        "cronjobs":                  "batch",
        "customresourcedefinitions": "apiextensions.k8s.io",
        "daemonsets":                "apps",
        "deployments":               "apps",
        "endpoints":                 "",
        "gateways":                  "gateway.networking.k8s.io",
        "gatewayclasses":            "gateway.networking.k8s.io",
        "httproutes":                "gateway.networking.k8s.io",
        "ingresses":                 "networking.k8s.io",
        "ingressclasses":            "networking.k8s.io",
        "jobs":                      "batch",
        "namespaces":                "",
        "networkpolicies":           "networking.k8s.io",
        "nodes":                     "",
        "pods":                      "",
        "replicasets":               "apps",
        "replicationcontrollers":    "",
        "serviceaccounts":           "",
        "services":                  "",
        "statefulsets":              "apps",
}

var dd = &amp;deadlockDetector{}
var ErrStopRetries = errors.New("stop retries")
var ErrFalcoEventIsNotFlow = errors.New("ignoring falco event, not a network flow")
var ErrFalcoIncompleteL3Flow = errors.New("ignoring incomplete falco l3 network flow")
var ErrFalcoIncompleteL4Flow = errors.New("ignoring incomplete falco l4 network flow")
var ErrFalcoInvalidPort = errors.New("ignoring incomplete falco flow due to bad ports")
var ErrFalcoTimestamp = errors.New("incomplete or incorrectly formatted timestamp found in Falco flow")
var falcoPort = ":5000"
var reIllumioTraffic *regexp.Regexp
var reParsePodNetworkInfo *regexp.Regexp

func init() <span class="cov8" title="1">{
        // Extract the relevant part of the output string
        reIllumioTraffic = regexp.MustCompile(`\((.*?)\)`)
        reParsePodNetworkInfo = regexp.MustCompile(`\b(\w+)=([^\s)]+)`)

}</span>

// ServerIsHealthy checks if a deadlock has occured within the threaded resource listing process.
func ServerIsHealthy() bool <span class="cov0" title="0">{
        dd.mutex.RLock()
        defer dd.mutex.RUnlock()
        if dd.processingResources &amp;&amp; time.Since(dd.timeStarted) &gt; 5*time.Minute </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// StreamResources handles the resource stream.
func (sm *streamManager) StreamResources(ctx context.Context, cancel context.CancelFunc) error <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                dd.processingResources = false
        }</span>()
        <span class="cov0" title="0">clusterConfig, err := rest.InClusterConfig()
        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("Error getting in-cluster config", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">var allResourcesSnapshotted sync.WaitGroup
        var snapshotCompleted sync.WaitGroup
        // Create a dynamic client
        dynamicClient, err := dynamic.NewForConfig(clusterConfig)
        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("Error creating dynamic client", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">clientset, err := NewClientSet()
        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("Failed to create clientset", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">apiGroups, err := clientset.Discovery().ServerGroups()
        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("Failed to discover API groups", zap.Error(err))
        }</span>
        <span class="cov0" title="0">foundGatewayAPIGroup := false

        // Check if the "gateway.networking.k8s.io" API group is not available, if it is not delete those resources and groups
        for _, group := range apiGroups.Groups </span><span class="cov0" title="0">{
                if group.Name == "gateway.networking.k8s.io" </span><span class="cov0" title="0">{
                        foundGatewayAPIGroup = true
                        break</span>
                }
        }

        // If the "gateway.networking.k8s.io" API group is not found, remove the resources
        <span class="cov0" title="0">if !foundGatewayAPIGroup </span><span class="cov0" title="0">{
                gatewayResources := []string{"gateways", "gatewayclasses", "httproutes"}
                for _, resource := range gatewayResources </span><span class="cov0" title="0">{
                        delete(resourceAPIGroupMap, resource)
                }</span>
        }

        <span class="cov0" title="0">snapshotCompleted.Add(1)
        dd.mutex.Lock()
        dd.timeStarted = time.Now()
        dd.processingResources = true
        dd.mutex.Unlock()
        resourceLister := &amp;ResourceManager{
                clientset:     clientset,
                logger:        sm.logger,
                dynamicClient: dynamicClient,
                streamManager: sm,
        }
        err = sendClusterMetadata(ctx, sm)
        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("Failed to send cluster metadata", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">for resource, apiGroup := range resourceAPIGroupMap </span><span class="cov0" title="0">{
                allResourcesSnapshotted.Add(1)
                go resourceLister.DynamicListAndWatchResources(ctx, cancel, resource, apiGroup, &amp;allResourcesSnapshotted, &amp;snapshotCompleted)
        }</span>
        <span class="cov0" title="0">allResourcesSnapshotted.Wait()
        err = sendResourceSnapshotComplete(sm)
        dd.timeStarted = time.Now()
        dd.mutex.Lock()
        dd.processingResources = false
        dd.mutex.Unlock()
        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("Failed to send resource snapshot complete", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">snapshotCompleted.Done()

        &lt;-ctx.Done()
        return ctx.Err()</span>
}

// StreamLogs handles the log stream.
func (sm *streamManager) StreamLogs(ctx context.Context) error <span class="cov0" title="0">{
        errCh := make(chan error, 1)

        go func() </span><span class="cov0" title="0">{
                errCh &lt;- sm.bufferedGrpcSyncer.ListenToLogStream()
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        case err := &lt;-errCh:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// findHubbleRelay returns a *CiliumFlowCollector if hubble relay is found in the given namespace
func (sm *streamManager) findHubbleRelay(ctx context.Context, ciliumNamespace string) *CiliumFlowCollector <span class="cov0" title="0">{
        // TODO: Add logic for a discoveribility function to decide which CNI to use.
        ciliumFlowCollector, err := newCiliumFlowCollector(ctx, sm.logger, ciliumNamespace)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return ciliumFlowCollector</span>
}

// StreamCiliumNetworkFlows handles the cilium network flow stream.
func (sm *streamManager) StreamCiliumNetworkFlows(ctx context.Context, ciliumNamespace string) error <span class="cov0" title="0">{
        // TODO: Add logic for a discoveribility function to decide which CNI to use.
        ciliumFlowCollector := sm.findHubbleRelay(ctx, ciliumNamespace)
        if ciliumFlowCollector == nil </span><span class="cov0" title="0">{
                sm.logger.Info("Failed to initialize Cilium Hubble Relay flow collector; disabling flow collector")
                return errors.New("hubble relay cannot be found")
        }</span> else<span class="cov0" title="0"> {
                for </span><span class="cov0" title="0">{
                        err := ciliumFlowCollector.exportCiliumFlows(ctx, *sm)
                        if err != nil </span><span class="cov0" title="0">{
                                sm.logger.Warn("Failed to collect and export flows from Cilium Hubble Relay", zap.Error(err))
                                sm.streamClient.disableNetworkFlowsCilium = true
                                return err
                        }</span>
                }
        }
}

// StreamFalcoNetworkFlows handles the falco network flow stream.
func (sm *streamManager) StreamFalcoNetworkFlows(ctx context.Context) error <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                falcoFlow := &lt;-sm.streamClient.falcoEventChan
                if filterIllumioTraffic(falcoFlow) </span><span class="cov0" title="0">{
                        // Extract the relevant part of the output string
                        match := reIllumioTraffic.FindStringSubmatch(falcoFlow)
                        if len(match) &lt; 2 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">convertedFalcoFlow, err := parsePodNetworkInfo(match[1])
                        if convertedFalcoFlow == nil </span><span class="cov0" title="0">{
                                // If the event can't be parsed, consider that it's not a flow event and just ignore it.
                                // If the event has bad ports in any way ignore it.
                                // If the event has an incomplete L3/L4 layer lets just ignore it.
                                continue</span>
                        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                                sm.logger.Error("Failed to parse Falco event into flow", zap.Error(err))
                                return err
                        }</span>
                        <span class="cov0" title="0">err = sendNetworkFlowRequest(sm, convertedFalcoFlow)
                        if err != nil </span><span class="cov0" title="0">{
                                sm.logger.Error("Failed to send Falco flow", zap.Error(err))
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        continue</span>
                }
        }
}

// StreamKeepalives loops infinitely as long as the keepalives are working. This
// should be run inside a goroutine in every `connectAndStream*` function
func (sm *streamManager) StreamKeepalives(
        ctx context.Context,
        period time.Duration,
        streamType StreamType,
) error <span class="cov0" title="0">{
        timer := time.NewTimer(jitterTime(period, 0.10))
        defer timer.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-timer.C:<span class="cov0" title="0">
                        err := sendKeepalive(sm, streamType)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">timer.Reset(jitterTime(period, 0.10))</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                }
        }
}

// connectAndStreamCiliumNetworkFlows creates networkFlowsStream client and
// begins the streaming of network flows. Also starts a goroutine to send
// keepalives at the configured period
func connectAndStreamCiliumNetworkFlows(logger *zap.Logger, sm *streamManager, KeepalivePeriod time.Duration) error <span class="cov0" title="0">{
        ciliumCtx, ciliumCancel := context.WithCancel(context.Background())
        defer ciliumCancel()

        sendCiliumNetworkFlowsStream, err := sm.streamClient.client.SendKubernetesNetworkFlows(ciliumCtx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to connect to server", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">sm.streamClient.networkFlowsStream = sendCiliumNetworkFlowsStream

        go func() </span><span class="cov0" title="0">{
                err := sm.StreamKeepalives(ciliumCtx, KeepalivePeriod, STREAM_NETWORK_FLOWS)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to send keepalives", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">err = sm.StreamCiliumNetworkFlows(ciliumCtx, sm.streamClient.ciliumNamespace)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, ErrHubbleNotFound) || errors.Is(err, ErrNoPortsAvailable) </span><span class="cov0" title="0">{
                        logger.Warn("Disabling Cilium flow collection", zap.Error(err))
                        return ErrStopRetries
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// connectAndStreamFalcoNetworkFlows creates networkFlowsStream client and
// begins the streaming of network flows. Also starts a goroutine to send
// keepalives at the configured period
func connectAndStreamFalcoNetworkFlows(logger *zap.Logger, sm *streamManager, KeepalivePeriod time.Duration) error <span class="cov0" title="0">{
        falcoCtx, falcoCancel := context.WithCancel(context.Background())
        defer falcoCancel()

        sendFalcoNetworkFlows, err := sm.streamClient.client.SendKubernetesNetworkFlows(falcoCtx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to connect to server", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">sm.streamClient.networkFlowsStream = sendFalcoNetworkFlows

        go func() </span><span class="cov0" title="0">{
                err := sm.StreamKeepalives(falcoCtx, KeepalivePeriod, STREAM_NETWORK_FLOWS)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to send keepalives", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">err = sm.StreamFalcoNetworkFlows(falcoCtx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to stream Falco network flows", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// connectAndStreamResources creates resourceStream client and begins the
// streaming of resources. Also starts a goroutine to send keepalives at the
// configured period
func connectAndStreamResources(logger *zap.Logger, sm *streamManager, KeepalivePeriod time.Duration) error <span class="cov0" title="0">{
        resourceCtx, resourceCancel := context.WithCancel(context.Background())
        defer resourceCancel()

        SendKubernetesResourcesStream, err := sm.streamClient.client.SendKubernetesResources(resourceCtx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to connect to server", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">sm.streamClient.resourceStream = SendKubernetesResourcesStream

        go func() </span><span class="cov0" title="0">{
                err := sm.StreamKeepalives(resourceCtx, KeepalivePeriod, STREAM_RESOURCES)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to send keepalives", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">err = sm.StreamResources(resourceCtx, resourceCancel)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to bootup and stream resources", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// connectAndStreamLogs creates sendLogs client and begins the streaming of
// logs. Also starts a goroutine to send keepalives at the configured period
func connectAndStreamLogs(logger *zap.Logger, sm *streamManager, KeepalivePeriod time.Duration) error <span class="cov0" title="0">{
        logCtx, logCancel := context.WithCancel(context.Background())
        defer logCancel()

        SendLogsStream, err := sm.streamClient.client.SendLogs(logCtx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to connect to server", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">sm.streamClient.logStream = SendLogsStream
        sm.bufferedGrpcSyncer.UpdateClient(sm.streamClient.logStream, sm.streamClient.conn)

        go func() </span><span class="cov0" title="0">{
                err := sm.StreamKeepalives(logCtx, KeepalivePeriod, STREAM_LOGS)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to send keepalives", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">err = sm.StreamLogs(logCtx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to bootup and stream logs", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Generic function to manage any stream with backoff and reconnection logic.
func manageStream(
        logger *zap.Logger,
        connectAndStream func(*zap.Logger, *streamManager, time.Duration) error,
        sm *streamManager,
        done chan struct{},
        KeepalivePeriod time.Duration,
) <span class="cov0" title="0">{
        defer close(done)

        f := func() error </span><span class="cov0" title="0">{
                return connectAndStream(logger, sm, KeepalivePeriod)
        }</span>

        // If a stream goes down, try to reconnect. With exponential backoff
        <span class="cov0" title="0">funcWithBackoff := func() error </span><span class="cov0" title="0">{
                return exponentialBackoff(backoffOpts{
                        InitialBackoff:       1 * time.Second,
                        MaxBackoff:           1 * time.Minute,
                        MaxJitterPct:         0.20,
                        SevereErrorThreshold: 10,
                        ExponentialFactor:    2.0,
                        Logger: logger.With(
                                zap.String("name", "retry_connect_and_stream"),
                        ),
                }, f)
        }</span>

        // If reapated attempts to connect fail, that is, the "SevereErrorThreshold"
        // in the above backoff is triggered, then wait and try again. By setting
        // ExponentialFactor to 1, we will wait the same amount of time between every
        // attempt. This is desirable
        <span class="cov0" title="0">funcWithBackoffAndReset := func() error </span><span class="cov0" title="0">{
                return exponentialBackoff(backoffOpts{
                        InitialBackoff:       10 * time.Minute,
                        MaxBackoff:           10 * time.Second,
                        MaxJitterPct:         0.10,
                        SevereErrorThreshold: math.MaxInt,
                        // Setting ExponentialFactor 1 will cause the backoff timer to stay
                        // constant.
                        ExponentialFactor: 1,
                        Logger: logger.With(
                                zap.String("name", "reset_retry_connect_and_stream"),
                        ),
                }, funcWithBackoff)
        }</span>

        <span class="cov0" title="0">err := funcWithBackoffAndReset()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to reset connectAndStream. Something is very wrong", zap.Error(err))
                return
        }</span>
}

// ConnectStreams will continue to reboot and restart the main operations within
// the operator if any disconnects or errors occur.
func ConnectStreams(ctx context.Context, logger *zap.Logger, envMap EnvironmentConfig, bufferedGrpcSyncer *BufferedGrpcWriteSyncer) <span class="cov0" title="0">{
        // Falco channels communicate news events between http server and our network flows strea,
        falcoEventChan := make(chan string)
        http.HandleFunc("/", NewFalcoEventHandler(falcoEventChan))

        // Start our falco server and have it passively listen, if it fails, try to just restart it.
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        // Create a custom listener, this listener has SO_REUSEADDR option set by default
                        listener, err := net.Listen("tcp", falcoPort)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Fatal("Failed to listen on Falco port", zap.String("address", falcoPort), zap.Error(err))
                        }</span>

                        // Create the HTTP server
                        <span class="cov0" title="0">falcoEvent := &amp;http.Server{Addr: falcoPort}

                        logger.Info("Falco server listening", zap.String("address", falcoPort))
                        err = falcoEvent.Serve(listener)
                        if err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                logger.Error("Falco server failed, restarting in 5 seconds", zap.Error(err))
                                // Giving some time before attempting to restart.....
                                time.Sleep(5 * time.Second)
                        }</span>
                }
        }()

        // We want to avoid many cloud-operator instances all trying to authenticate
        // at the same time.
        //
        // To that effect, we add a 5 second sleep with 20% jitter here. That way even
        // if you onboard 100 cloud-operators at the same time, they won't all be
        // synced up. Normal network delays may do this for us, but we don't want to
        // rely on that.
        <span class="cov0" title="0">resetTimer := time.NewTimer(jitterTime(5*time.Second, 0.20))
        attempt := 0

        // The happy path blocks inside the for loop.
        // The unhappy path exits the for loop and hits the top-level select.
        for </span><span class="cov0" title="0">{
                failureReason := ""
                attempt++
                logger.Debug("Trying to authenticate and open streams", zap.Int("attempt", attempt))

                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Warn("Context canceled while trying to authenticate and open streams")
                        return</span>
                case &lt;-resetTimer.C:<span class="cov0" title="0">
                        authConContext, authConContextCancel := context.WithCancel(ctx)
                        authConn, client, err := NewAuthenticatedConnection(authConContext, logger, envMap)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("Failed to establish initial connection; will retry", zap.Error(err))
                                // When we try this loop again, we wait 10 seconds with 20% jitter.
                                resetTimer.Reset(jitterTime(10*time.Second, 0.20))
                                authConContextCancel()
                                failureReason = "Failed to establish initial connection"
                                break</span>
                        }

                        <span class="cov0" title="0">streamClient := &amp;streamClient{
                                conn:                      authConn,
                                client:                    client,
                                ciliumNamespace:           envMap.CiliumNamespace,
                                disableNetworkFlowsCilium: false,
                                falcoEventChan:            falcoEventChan,
                                flowCollector:             pb.FlowCollector_FLOW_COLLECTOR_UNSPECIFIED,
                        }
                        // Initialize the WaitGroup with a count of 1.
                        streamClient.flowCollectorWG.Add(1)

                        sm := &amp;streamManager{
                                streamClient:       streamClient,
                                logger:             logger,
                                bufferedGrpcSyncer: bufferedGrpcSyncer,
                        }
                        ciliumFlowCollector := sm.findHubbleRelay(ctx, sm.streamClient.ciliumNamespace)
                        if ciliumFlowCollector == nil </span><span class="cov0" title="0">{
                                sm.streamClient.disableNetworkFlowsCilium = true
                                sm.streamClient.flowCollector = pb.FlowCollector_FLOW_COLLECTOR_FALCO
                        }</span> else<span class="cov0" title="0"> {
                                sm.streamClient.disableNetworkFlowsCilium = false
                                sm.streamClient.flowCollector = pb.FlowCollector_FLOW_COLLECTOR_CILIUM
                        }</span>
                        // If neither is available
                        <span class="cov0" title="0">if sm.streamClient.flowCollector != pb.FlowCollector_FLOW_COLLECTOR_CILIUM &amp;&amp;
                                sm.streamClient.flowCollector != pb.FlowCollector_FLOW_COLLECTOR_FALCO </span><span class="cov0" title="0">{
                                sm.streamClient.flowCollector = pb.FlowCollector_FLOW_COLLECTOR_DISABLED
                        }</span>
                        // Wait for the flow collector decision
                        <span class="cov0" title="0">sm.streamClient.flowCollectorWG.Done()
                        // Send the cluster metadata (it will block internally until the decision is done).
                        if err := sendClusterMetadata(ctx, sm); err != nil </span><span class="cov0" title="0">{
                                logger.Error("Failed to send cluster metadata", zap.Error(err))
                                failureReason = "Failed to send cluster metadata"
                                authConContextCancel()
                                break</span>
                        }

                        <span class="cov0" title="0">resourceDone := make(chan struct{})
                        logDone := make(chan struct{})
                        var ciliumDone, falcoDone chan struct{}
                        sm.bufferedGrpcSyncer.done = logDone

                        go manageStream(logger, connectAndStreamResources, sm, resourceDone, envMap.KeepalivePeriods.KubernetesResources)
                        go manageStream(logger, connectAndStreamLogs, sm, logDone, envMap.KeepalivePeriods.Logs)
                        // Only start network flows stream if not disabled
                        if !sm.streamClient.disableNetworkFlowsCilium </span><span class="cov0" title="0">{
                                ciliumDone = make(chan struct{})
                                go manageStream(logger, connectAndStreamCiliumNetworkFlows, sm, ciliumDone, envMap.KeepalivePeriods.KubernetesNetworkFlows)
                        }</span>
                        <span class="cov0" title="0">if sm.streamClient.disableNetworkFlowsCilium </span><span class="cov0" title="0">{
                                falcoDone := make(chan struct{})
                                go manageStream(logger, connectAndStreamFalcoNetworkFlows, sm, falcoDone, envMap.KeepalivePeriods.KubernetesNetworkFlows)
                        }</span>

                        // Block until one of the streams fail. Then we will jump to the top of
                        // this loop &amp; try again: authenticate and open the streams.
                        <span class="cov0" title="0">logger.Info("All streams are open and running")
                        select </span>{
                        case &lt;-ciliumDone:<span class="cov0" title="0">
                                failureReason = "Cilium network flow stream closed"</span>
                        case &lt;-falcoDone:<span class="cov0" title="0">
                                failureReason = "Falco network flow stream closed"</span>
                        case &lt;-resourceDone:<span class="cov0" title="0">
                                failureReason = "Resource stream closed"</span>
                        case &lt;-logDone:<span class="cov0" title="0">
                                failureReason = "Log stream closed"</span>
                        }
                        <span class="cov0" title="0">authConContextCancel()</span>
                }
                <span class="cov0" title="0">logger.Warn("One or more streams have been closed; closing and reopening the connection to CloudSecure",
                        zap.String("failureReason", failureReason),
                        zap.Int("attempt", attempt),
                )</span>
        }
}

// NewAuthenticatedConnection gets a valid token and creats a connection to CloudSecure.
func NewAuthenticatedConnection(ctx context.Context, logger *zap.Logger, envMap EnvironmentConfig) (*grpc.ClientConn, pb.KubernetesInfoServiceClient, error) <span class="cov0" title="0">{
        authn := Authenticator{Logger: logger}

        clientID, clientSecret, err := authn.ReadCredentialsK8sSecrets(ctx, envMap.ClusterCreds)
        if errors.Is(err, ErrCredentialNotFoundInK8sSecret) </span><span class="cov0" title="0">{
                logger.Debug("Secret is not populated yet", zap.Error(err))
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                logger.Error("Could not read K8s credentials", zap.Error(err))
        }</span>

        // At the end of this block, have the clientID and clientSecret variables
        // populated. If not, we should have returned. A comment like this is
        // code-smell, meaning that this block should be hoisted to a function
        <span class="cov0" title="0">if clientID == "" &amp;&amp; clientSecret == "" </span><span class="cov0" title="0">{
                OnboardingCredentials, err := authn.GetOnboardingCredentials(ctx, envMap.OnboardingClientId, envMap.OnboardingClientSecret)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to get onboarding credentials", zap.Error(err))
                }</span>
                <span class="cov0" title="0">responseData, err := Onboard(ctx, envMap.TlsSkipVerify, envMap.OnboardingEndpoint, OnboardingCredentials, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to register cluster", zap.Error(err))
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">err = authn.WriteK8sSecret(ctx, responseData, envMap.ClusterCreds)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to write secret to Kubernetes", zap.Error(err))
                }</span>

                // k8s may take some time writing the secret. Here we will try 'maxRetries'
                // times, waiting 'waitDuration' seconds between each try. Even a single 1
                // second wait is probably fine, but just to be semantic this wait is done
                // as a poll.
                <span class="cov0" title="0">maxRetries := 5
                waitDuration := 1 * time.Second
                for i := 0; i &lt; maxRetries; i++ </span><span class="cov0" title="0">{
                        clientID, clientSecret, err = authn.ReadCredentialsK8sSecrets(ctx, envMap.ClusterCreds)
                        if errors.Is(err, ErrCredentialNotFoundInK8sSecret) </span><span class="cov0" title="0">{
                                logger.Debug("Secret is not populated yet", zap.Error(err))
                        }</span>
                        <span class="cov0" title="0">if clientID != "" &amp;&amp; clientSecret != "" </span><span class="cov0" title="0">{
                                err = nil
                                break</span>
                        }
                        <span class="cov0" title="0">time.Sleep(waitDuration)</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Could not read K8s credentials", zap.Error(err))
                        return nil, nil, err
                }</span>
        }
        <span class="cov0" title="0">conn, err := SetUpOAuthConnection(ctx, logger, envMap.TokenEndpoint, envMap.TlsSkipVerify, clientID, clientSecret)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to set up an OAuth connection", zap.Error(err))
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">client := pb.NewKubernetesInfoServiceClient(conn)

        return conn, client, err</span>
}

// jitterTime subtracts a percentage from the base time, in order to introduce
// jitter. maxJitterPct must be in the range [0, 1).
//
// jitter is a technical term, meaning "a signal's deviation from true
// periodicity". This is desirable in distributed systems, because if all agents
// synchronize their messages, we stop calling that API requests and start
// calling that a DDoS attack.
func jitterTime(base time.Duration, maxJitterPct float64) time.Duration <span class="cov0" title="0">{
        jitterPct := rand.Float64() * maxJitterPct // [0, maxJitterPct)
        return time.Duration(float64(base) * (1. - jitterPct))
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package controller

import (
        "context"
        "fmt"

        "go.uber.org/zap"
        "k8s.io/apimachinery/pkg/watch"

        pb "github.com/illumio/cloud-operator/api/illumio/cloud/k8sclustersync/v1"
        "github.com/illumio/cloud-operator/internal/version"
)

// Helper function to send a request to the resource stream
func sendToResourceStream(logger *zap.Logger, stream pb.KubernetesInfoService_SendKubernetesResourcesClient, request *pb.SendKubernetesResourcesRequest) error <span class="cov0" title="0">{
        if err := stream.Send(request); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to send request", zap.Stringer("request", request), zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// sendObjectData sends a KubernetesObjectData to CloudSecure into the given stream.
// Its used for the intial boot up of the operator so that is can stream everything currently in the cluster.
func sendObjectData(sm *streamManager, metadata *pb.KubernetesObjectData) error <span class="cov0" title="0">{
        request := &amp;pb.SendKubernetesResourcesRequest{
                Request: &amp;pb.SendKubernetesResourcesRequest_ResourceData{
                        ResourceData: metadata,
                },
        }
        return sendToResourceStream(sm.logger, sm.streamClient.resourceStream, request)
}</span>

// sendNetworkFlowRequest sends a network flow to the networkFlowsStream
func sendNetworkFlowRequest(sm *streamManager, flow interface{}) error <span class="cov0" title="0">{
        var request *pb.SendKubernetesNetworkFlowsRequest

        switch f := flow.(type) </span>{
        case *pb.FalcoFlow:<span class="cov0" title="0">
                request = &amp;pb.SendKubernetesNetworkFlowsRequest{
                        Request: &amp;pb.SendKubernetesNetworkFlowsRequest_FalcoFlow{
                                FalcoFlow: f,
                        },
                }</span>
        case *pb.CiliumFlow:<span class="cov0" title="0">
                request = &amp;pb.SendKubernetesNetworkFlowsRequest{
                        Request: &amp;pb.SendKubernetesNetworkFlowsRequest_CiliumFlow{
                                CiliumFlow: f,
                        },
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported flow type: %T", flow)</span>
        }
        <span class="cov0" title="0">if err := sm.streamClient.networkFlowsStream.Send(request); err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("Failed to send network flow", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// streamMutationObjectData does type gymnastics then sends the result over the
// wire. It "upgrades" a KubernetesObjectData into a KubernetesResourceMutation
// (which can be sent over the wire). It needs to use information from the
// watch.EventType to accomplish this
func streamMutationObjectData(sm *streamManager, metadata *pb.KubernetesObjectData, eventType watch.EventType) error <span class="cov0" title="0">{
        var mutation *pb.KubernetesResourceMutation
        switch eventType </span>{
        case watch.Added:<span class="cov0" title="0">
                mutation = &amp;pb.KubernetesResourceMutation{
                        Mutation: &amp;pb.KubernetesResourceMutation_CreateResource{
                                CreateResource: metadata,
                        },
                }</span>
        case watch.Deleted:<span class="cov0" title="0">
                mutation = &amp;pb.KubernetesResourceMutation{
                        Mutation: &amp;pb.KubernetesResourceMutation_DeleteResource{
                                DeleteResource: metadata,
                        },
                }</span>
        case watch.Modified:<span class="cov0" title="0">
                mutation = &amp;pb.KubernetesResourceMutation{
                        Mutation: &amp;pb.KubernetesResourceMutation_UpdateResource{
                                UpdateResource: metadata,
                        },
                }</span>
        }
        <span class="cov0" title="0">request := &amp;pb.SendKubernetesResourcesRequest{
                Request: &amp;pb.SendKubernetesResourcesRequest_KubernetesResourceMutation{
                        KubernetesResourceMutation: mutation,
                },
        }
        return sendToResourceStream(sm.logger, sm.streamClient.resourceStream, request)</span>
}

// sendClusterMetadata sends a message to indicate current cluster metadata
func sendClusterMetadata(ctx context.Context, sm *streamManager) error <span class="cov0" title="0">{
        // Wait until the flow collector decision is complete.
        sm.streamClient.flowCollectorWG.Wait()

        clusterUid, err := GetClusterID(ctx, sm.logger)
        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("Error getting cluster id", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">clientset, err := NewClientSet()
        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("Error creating clientset", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">kubernetesVersion, err := clientset.Discovery().ServerVersion()
        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("Error getting Kubernetes version", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">request := &amp;pb.SendKubernetesResourcesRequest{
                Request: &amp;pb.SendKubernetesResourcesRequest_ClusterMetadata{
                        ClusterMetadata: &amp;pb.KubernetesClusterMetadata{
                                Uid:               clusterUid,
                                KubernetesVersion: kubernetesVersion.String(),
                                OperatorVersion:   version.Version(),
                                FlowCollector:     sm.streamClient.flowCollector,
                        },
                },
        }
        return sendToResourceStream(sm.logger, sm.streamClient.resourceStream, request)</span>
}

// sendResourceSnapshotComplete sends a message to indicate that the initial inventory snapshot has been completely streamed into the given stream.
func sendResourceSnapshotComplete(sm *streamManager) error <span class="cov0" title="0">{
        request := &amp;pb.SendKubernetesResourcesRequest{
                Request: &amp;pb.SendKubernetesResourcesRequest_ResourceSnapshotComplete{},
        }
        return sendToResourceStream(sm.logger, sm.streamClient.resourceStream, request)
}</span>

// sendKeepalive accepts a stream type &amp; sends a keepalive ping on that stream
func sendKeepalive(sm *streamManager, st StreamType) error <span class="cov0" title="0">{
        var err error

        switch st </span>{
        case STREAM_NETWORK_FLOWS:<span class="cov0" title="0">
                err = sm.streamClient.networkFlowsStream.Send(&amp;pb.SendKubernetesNetworkFlowsRequest{
                        Request: &amp;pb.SendKubernetesNetworkFlowsRequest_Keepalive{
                                Keepalive: &amp;pb.Keepalive{},
                        },
                })</span>
        case STREAM_RESOURCES:<span class="cov0" title="0">
                err = sm.streamClient.resourceStream.Send(&amp;pb.SendKubernetesResourcesRequest{
                        Request: &amp;pb.SendKubernetesResourcesRequest_Keepalive{
                                Keepalive: &amp;pb.Keepalive{},
                        },
                })</span>
        case STREAM_LOGS:<span class="cov0" title="0">
                err = sm.streamClient.logStream.Send(&amp;pb.SendLogsRequest{
                        Request: &amp;pb.SendLogsRequest_Keepalive{
                                Keepalive: &amp;pb.Keepalive{},
                        },
                })</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported stream type: %s", st)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("Failed to send keepalive on stream", zap.String("stream", string(st)), zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package controller

import (
        "fmt"
        "time"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "golang.org/x/exp/constraints"
)

type backoffOpts struct {
        InitialBackoff       time.Duration
        MaxBackoff           time.Duration
        MaxJitterPct         float64
        SevereErrorThreshold int
        ExponentialFactor    float64
        Logger               *zap.Logger
}

var _ zapcore.ObjectMarshaler = &amp;backoffOpts{}

func (a backoffOpts) MarshalLogObject(enc zapcore.ObjectEncoder) error <span class="cov0" title="0">{
        enc.AddDuration("initial_backoff", a.InitialBackoff)
        enc.AddDuration("max_backoff", a.MaxBackoff)
        enc.AddFloat64("exponential_factor", a.ExponentialFactor)
        enc.AddFloat64("max_jitter_pct", a.MaxJitterPct)
        enc.AddInt("severe_error_threshold", a.SevereErrorThreshold)
        return nil
}</span>

type Action func() error

func clamp[T constraints.Ordered](minimum, val, maximum T) T <span class="cov0" title="0">{
        if val &lt; minimum </span><span class="cov0" title="0">{
                return minimum
        }</span>
        <span class="cov0" title="0">if val &gt; maximum </span><span class="cov0" title="0">{
                return maximum
        }</span>
        <span class="cov0" title="0">return val</span>
}

type state struct {
        backoff             time.Duration
        timer               *time.Timer
        consecutiveFailures int
        opts                backoffOpts
}

func exponentialBackoff(opts backoffOpts, action Action) error <span class="cov0" title="0">{
        s := state{
                backoff:             opts.InitialBackoff,
                consecutiveFailures: 0,
                // Don't wait before the first attempt to execute the action.
                timer: time.NewTimer(0),
                opts:  opts,
        }
        defer s.timer.Stop()
        opts.Logger.Debug("Making first attempt", zap.Inline(opts))

        for range s.timer.C </span><span class="cov0" title="0">{
                err := action()

                if err != nil </span><span class="cov0" title="0">{
                        s.HappyPathResetBackoff()
                        continue</span>
                }

                // Give up after failing more than SevereErrorThreshold times
                <span class="cov0" title="0">givingUp := s.consecutiveFailures &gt;= opts.SevereErrorThreshold
                lg := opts.Logger.Debug
                if givingUp </span><span class="cov0" title="0">{
                        lg = opts.Logger.Error
                }</span>
                <span class="cov0" title="0">lg("Error in backoff function",
                        zap.Bool("severe_failure", givingUp),
                        zap.Int("consecutive_failures", s.consecutiveFailures),
                        zap.Error(err),
                )

                if !givingUp </span><span class="cov0" title="0">{
                        s.AddBackoff(1)
                        continue</span>
                }

                <span class="cov0" title="0">s.UnhappyPathResetBackoff()
                return fmt.Errorf("failed %d times", s.consecutiveFailures)</span>
        }

        // unreachable
        <span class="cov0" title="0">return fmt.Errorf("broke out of backoff loop")</span>
}

func (s *state) AddBackoff(count int) <span class="cov0" title="0">{
        for range count </span><span class="cov0" title="0">{
                s.consecutiveFailures++

                sleep := clamp(s.opts.InitialBackoff, jitterTime(s.backoff, s.opts.MaxJitterPct), s.opts.MaxBackoff)
                s.opts.Logger.Debug("Backing off", zap.Duration("sleep", sleep), zap.Int("consecutive_failures", s.consecutiveFailures))
                s.timer.Reset(sleep)
                nextBackoff := time.Duration(float64(s.backoff) * s.opts.ExponentialFactor)
                s.backoff = min(nextBackoff, s.opts.MaxBackoff)
        }</span>
}

func (s *state) HappyPathResetBackoff() <span class="cov0" title="0">{
        s.opts.Logger.Debug("Resetting backoff timer because of success. No need to wait so long when things are well")
        s.resetBackoff()
}</span>

func (s *state) UnhappyPathResetBackoff() <span class="cov0" title="0">{
        s.opts.Logger.Debug("Resetting backoff timer because of severe error")
        s.resetBackoff()
}</span>

func (s *state) resetBackoff() <span class="cov0" title="0">{
        s.consecutiveFailures = 0
        s.backoff = s.opts.InitialBackoff
        s.timer.Reset(s.opts.InitialBackoff)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright 2024 Illumio, Inc. All Rights Reserved.

package testhelper

import (
        "os/exec"
)

// setupTestCluster creates a new KIND cluster for testing.
func SetupTestCluster() error <span class="cov8" title="1">{
        cmd := exec.Command("kind", "create", "cluster", "--name", "my-test-cluster", "--config", "../../kind-config.yaml")
        return cmd.Run()
}</span>

// tearDownTestCluster destroys the KIND test cluster.
func TearDownTestCluster() error <span class="cov0" title="0">{
        cmd := exec.Command("kind", "delete", "cluster", "--name", "my-test-cluster")
        return cmd.Run()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright 2024 Illumio, Inc. All Rights Reserved.

package version

var version string

// Version returns the version of the operator.
func Version() string <span class="cov0" title="0">{
        return version
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
